#!/usr/bin/env python3
import argparse
import json
import sys
from web3 import Web3
from dotenv import load_dotenv
import os

# Load .env from current directory
load_dotenv()

# ABI for Uniswap V2 Router (only getAmountsOut is needed)
V2_ROUTER_ABI = [
    {
        "inputs": [
            {"internalType": "uint256", "name": "amountIn", "type": "uint256"},
            {"internalType": "address[]", "name": "path", "type": "address[]"}
        ],
        "name": "getAmountsOut",
        "outputs": [{"internalType": "uint256[]", "name": "amounts", "type": "uint256[]"}],
        "stateMutability": "view",
        "type": "function"
    }
]

# ABI for ERC20 (only symbol and decimals for logging)
ERC20_ABI = [
    {"inputs": [], "name": "symbol", "outputs": [{"internalType": "string", "name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
    {"inputs": [], "name": "decimals", "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}], "stateMutability": "view", "type": "function"}
]

def get_token_info(w3, address):
    try:
        token = w3.eth.contract(address=address, abi=ERC20_ABI)
        return token.functions.symbol().call(), token.functions.decimals().call()
    except:
        return address[:6], 18

def main():
    parser = argparse.ArgumentParser(description="Uniswap Smart Path CLI Tool (Replication)")
    parser.add_argument("--rpc-endpoint", help="RPC endpoint URL")
    parser.add_argument("--token-in", required=True, help="Address of token to swap from")
    parser.add_argument("--token-out", required=True, help="Address of token to swap to")
    parser.add_argument("--exact-amount-in", type=int, required=True, help="Amount in atomic units")
    parser.add_argument("--pivot-tokens", help="Comma-separated list of pivot tokens")
    parser.add_argument("--v2-factory", help="Uniswap V2 Factory address (unused in simple router call)")
    parser.add_argument("--v2-router", required=True, help="Uniswap V2 Router address")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")

    args = parser.parse_args()

    # Priority: CLI arg > .env > default
    rpc_url = args.rpc_endpoint or os.getenv("ANVIL_RPC_URL") or "http://127.0.0.1:8545"
    w3 = Web3(Web3.HTTPProvider(rpc_url))

    if not w3.is_connected():
        print(f"Error: Could not connect to RPC at {rpc_url}")
        sys.exit(1)

    router = w3.eth.contract(address=Web3.to_checksum_address(args.v2_router), abi=V2_ROUTER_ABI)
    
    token_in = Web3.to_checksum_address(args.token_in)
    token_out = Web3.to_checksum_address(args.token_out)
    
    pivots = [Web3.to_checksum_address(p.strip()) for p in args.pivot_tokens.split(",")] if args.pivot_tokens else []
    
    # Generate candidate paths
    paths = [[token_in, token_out]]
    for p in pivots:
        if p != token_in and p != token_out:
            paths.append([token_in, p, token_out])

    best_amount = 0
    best_path = None

    print(f"Finding best swap path for:")
    sym_in, dec_in = get_token_info(w3, token_in)
    sym_out, dec_out = get_token_info(w3, token_out)
    print(f"  Token In:  {token_in} ({sym_in})")
    print(f"  Token Out: {token_out} ({sym_out})")
    print(f"  Amount In: {args.exact_amount_in}")

    print("V2 Candidate Pools:")
    for path in paths:
        try:
            amounts = router.functions.getAmountsOut(args.exact_amount_in, path).call()
            output_amount = amounts[-1]
            
            path_str = " -> ".join([p[:6] for p in path])
            print(f"  Path {path_str}: Output = {output_amount}")
            
            if output_amount > best_amount:
                best_amount = output_amount
                best_path = path
        except Exception as e:
            if args.debug:
                print(f"  Path {'->'.join(path)}: Failed ({str(e)})")
            continue

    if best_path:
        print("Found the best swap path.")
        print(f"Uniswap version to use: V2. Path:")
        print(f"    {tuple(best_path)}")
        print(f"Estimated output: {best_amount} atomic units")
    else:
        print("No valid path found.")
        sys.exit(1)

if __name__ == "__main__":
    main()
