import re
import sys
import subprocess
import os
from pathlib import Path

def get_solidity_version(file_path):
    """
    Parses the Solidity file to find the pragma version.
    Returns the version string (e.g., '0.8.20').
    """
    try:
        with open(file_path, 'r') as f:
            content = f.read()
            
        # Regex to find pragma (simplified)
        # Matches: pragma solidity ^0.8.0; or pragma solidity 0.8.0;
        match = re.search(r'pragma\s+solidity\s+([^;]+);', content)
        if match:
            version_constraint = match.group(1).strip()
            # Clean up the constraint to get a specific version
            # This is a heuristic. Ideally we use semantic versioning parsing.
            # For now, we strip caret and assume highest compatible or exact.
            
            clean_ver = version_constraint.replace('^', '').replace('>=', '').replace('<', '').strip()
            # Handle ranges like ">=0.6.0 <0.8.0" -> take 0.6.0 (dangerous but simple)
            if ' ' in clean_ver:
                clean_ver = clean_ver.split(' ')[0]
            
            return clean_ver
    except Exception as e:
        print(f"Error reading file: {e}")
    return None

def install_and_use_version(version):
    """
    Uses solc-select to install and set the version.
    """
    print(f"[*] Detected Solidity version: {version}")
    
    # Check if version is installed
    try:
        subprocess.run(['solc-select', 'install', version], check=True)
        subprocess.run(['solc-select', 'use', version], check=True)
        print(f"[+] Switched to solc {version}")
    except subprocess.CalledProcessError as e:
        print(f"[!] Error setting solc version: {e}")
        # Fallback to 0.8.20 if detection fails? No, better to fail loud.
        return False
    return True

def generate_remappings(base_path):
    """
    Scans the directory for subdirectories that look like libraries/packages
    and generates remappings for foundry.
    """
    remappings = []
    # Common prefixes found in Etherscan/BSCScan multi-file exports
    # Usually they look like '@openzeppelin/contracts/token/ERC20/ERC20.sol'
    # and on disk it is 'lib/@openzeppelin/contracts/...' or just '@openzeppelin/...'
    
    # We'll look for folders in the root of the source
    path = Path(base_path)
    for item in path.iterdir():
        if item.is_dir():
            # If we find a directory like '@openzeppelin', we map it
            if item.name.startswith('@') or item.name in ['contracts', 'lib', 'deps']:
                remappings.append(f"{item.name}/={item.absolute()}/")
    
    return remappings

def update_foundry_toml(version, remappings):
    """
    Updates or creates foundry.toml with specific solc version and remappings.
    """
    remap_str = "\n".join([f'    "{r}",' for r in remappings])
    toml_content = f"""
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc = "{version}"
optimizer = true
optimizer_runs = 200
remappings = [
{remap_str}
]
"""
    with open("foundry.toml", "w") as f:
        f.write(toml_content)
    print(f"[+] Updated foundry.toml with {len(remappings)} remappings")

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 compiler_manager.py <path_to_sol_file>")
        sys.exit(1)

    target_file = Path(sys.argv[1])
    if not target_file.exists():
        print(f"File not found: {target_file}")
        sys.exit(1)

    # Base directory for the project (usually the parent of src/ or the addr folder)
    # Target_Fetcher saves to downloads/{addr}/{ContractName}/*.sol
    project_root = target_file.parent
    
    version = get_solidity_version(target_file)
    if not version:
        print("[!] Could not detect solidity version. Defaulting to 0.8.20")
        version = "0.8.20"

    remappings = generate_remappings(project_root)

    if install_and_use_version(version):
        update_foundry_toml(version, remappings)
    else:
        sys.exit(1)

if __name__ == "__main__":
    main()
