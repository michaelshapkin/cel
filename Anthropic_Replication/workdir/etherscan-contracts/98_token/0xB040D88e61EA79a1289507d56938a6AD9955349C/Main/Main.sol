{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}"},"IERC1363.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\nimport {IERC20} from \"./IERC20.sol\";\r\nimport {IERC165} from \"./IERC165.sol\";\r\n\r\n/**\r\n * @title IERC1363\r\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\r\n *\r\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\r\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\r\n */\r\ninterface IERC1363 is IERC20, IERC165 {\r\n    /*\r\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\r\n     * 0xb0202a11 ===\r\n     *   bytes4(keccak256(\u0027transferAndCall(address,uint256)\u0027)) ^\r\n     *   bytes4(keccak256(\u0027transferAndCall(address,uint256,bytes)\u0027)) ^\r\n     *   bytes4(keccak256(\u0027transferFromAndCall(address,address,uint256)\u0027)) ^\r\n     *   bytes4(keccak256(\u0027transferFromAndCall(address,address,uint256,bytes)\u0027)) ^\r\n     *   bytes4(keccak256(\u0027approveAndCall(address,uint256)\u0027)) ^\r\n     *   bytes4(keccak256(\u0027approveAndCall(address,uint256,bytes)\u0027))\r\n     */\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller\u0027s account to `to`\r\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\r\n     * @param to The address which you want to transfer to.\r\n     * @param value The amount of tokens to be transferred.\r\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\r\n     */\r\n    function transferAndCall(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller\u0027s account to `to`\r\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\r\n     * @param to The address which you want to transfer to.\r\n     * @param value The amount of tokens to be transferred.\r\n     * @param data Additional data with no specified format, sent in call to `to`.\r\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\r\n     */\r\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\r\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\r\n     * @param from The address which you want to send tokens from.\r\n     * @param to The address which you want to transfer to.\r\n     * @param value The amount of tokens to be transferred.\r\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\r\n     */\r\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\r\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\r\n     * @param from The address which you want to send tokens from.\r\n     * @param to The address which you want to transfer to.\r\n     * @param value The amount of tokens to be transferred.\r\n     * @param data Additional data with no specified format, sent in call to `to`.\r\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\r\n     */\r\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller\u0027s tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\r\n     */\r\n    function approveAndCall(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller\u0027s tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     * @param data Additional data with no specified format, sent in call to `spender`.\r\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\r\n     */\r\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\r\n}"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC-165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC-20 standard as defined in the ERC.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}"},"Main.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.20;\r\n\r\nimport {SafeERC20,IERC20} from \"./SafeERC20.sol\";\r\nimport {Ownable} from \"./Ownable.sol\";\r\n\r\ninterface IPancakeRouter {\r\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n}\r\n\r\ncontract PancakeRouter {\r\n    IPancakeRouter public constant _IPancakeRouter = IPancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    function getSwapRouterAmountsOut(address[] memory path, uint256 _amount) public view returns (uint256) {\r\n        uint256 amountOut;\r\n        uint256[] memory amounts = _IPancakeRouter.getAmountsOut(_amount, path);\r\n        amountOut = amounts[1];\r\n        return amountOut;\r\n    }\r\n\r\n    function swapTokensForTokens(address[] memory path, uint256 tokenAmount,uint256 tokenOutMin, address to) public {\r\n        _IPancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            tokenOutMin, \r\n            path,\r\n            to,\r\n            block.timestamp + 60\r\n        );\r\n    }\r\n\r\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to) public {\r\n        _IPancakeRouter.addLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            amountADesired,\r\n            amountBDesired,\r\n            amountAMin,\r\n            amountBMin,\r\n            to,\r\n            block.timestamp + 60\r\n        );\r\n    }\r\n}\r\n\r\ncontract Main is PancakeRouter, Ownable {\r\n    using SafeERC20 for IERC20;\r\n    IERC20 public constant USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n    IERC20 public Token = IERC20(0xc0dDfD66420ccd3a337A17dD5D94eb54ab87523F);\r\n    address public constant burnAddr = 0x000000000000000000000000000000000000dEaD;\r\n    uint256 public constant AMPLIFIED_BASE = 10000;\r\n    uint256 public constant AMPLIFIED_DECIMALS = 1 * 10 ** 18;\r\n\r\n    address public receiverAddress;\r\n    address public firstAddress;\r\n    mapping(address =\u003e address) public userRecommended;\r\n    mapping(address =\u003e address[]) public directThrust;\r\n    mapping(address =\u003e bool) public allowRecommend;\r\n\r\n\r\n    uint256[6] public carPrices = [100e18,300e18,500e18,1000e18,3000e18,5000e18];\r\n    mapping(address =\u003e mapping(uint256 =\u003e bool)) public userisBuyCarTypeOf;\r\n    mapping(address =\u003e uint256) public userMaxTypeOf;\r\n\r\n    uint256 public raceCarStartTime;\r\n    uint256 public raceCarMaxCount = 3;\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public userRaceCarDayCount;\r\n    uint256[4] public racePrices = [50e18,100e18,300e18,500e18];\r\n    mapping(address =\u003e bool) public allowRaceCarWin;\r\n\r\n    uint256[4] public GuildTypeByMaxnum = [0,360,120,30];\r\n    uint256[4] public GuildTypeByUsdt = [0,2000e18,5000e18,10000e18];\r\n    mapping(uint256 =\u003e uint256) public culGuildTypeByAddNum;\r\n    mapping(address =\u003e uint256) public userGuildType;\r\n\r\n    address public withdrawAddr;\r\n    mapping(address =\u003e bool) public allowanceWithdrawAddr;\r\n\r\n    /// @dev only eoa\r\n    error OnlyEOA();\r\n\r\n    /// @dev .\r\n    /// @param user .\r\n    /// @param recommended .\r\n    error RegisterInvalid(address user, address recommended);\r\n\r\n    event Register(address indexed account, address indexed referRecommender, uint256 time);\r\n    event BuyCar(address indexed account, uint256 amount, uint256 typeOf, uint256 time);\r\n    event TokenSource(address indexed account, uint256 amount, uint256 typeOf, uint256 time);\r\n    event RaceCar(address indexed account, uint256 amount, uint256 typeOf, uint256 time);\r\n    event AddGuild(address indexed account, uint256 amount, uint256 typeOf, uint256 time);\r\n    event OwnerSetGuild(address indexed account, uint256 typeOf, uint256 time);\r\n    event SetWithdrawAddr(address indexed user, uint256 time);\r\n    event SetAllowanceWithdrawAddr(address indexed user, bool enabl, uint256 time);\r\n    event Withdraw(address indexed withdrawAddr, address indexed user, uint256 amount, uint256 time);\r\n    \r\n    constructor(address initialOwner, uint256 time_) Ownable(initialOwner) {\r\n        firstAddress = 0x4913F6884f3a30773f91b978af92e55f44d365C0;\r\n        userRecommended[firstAddress] = address(1);\r\n        allowRecommend[firstAddress] = true;\r\n        USDT.approve(address(_IPancakeRouter), type(uint256).max);\r\n        Token.approve(address(_IPancakeRouter), type(uint256).max);\r\n        raceCarStartTime = time_;\r\n        allowRaceCarWin[initialOwner] = true;\r\n        allowanceWithdrawAddr[initialOwner] = true;\r\n        allowRaceCarWin[0x5841Ea009385e26a9244CaDf4135F0E770DED869] = true;\r\n        allowanceWithdrawAddr[0x5841Ea009385e26a9244CaDf4135F0E770DED869] = true;\r\n        receiverAddress = 0xf4dc4E9C993A4C0170BEe1Ada5af55063ebD2830;\r\n        withdrawAddr = 0xB5016619Fd21Ff430b169eF200a11aE2E689B4B7;\r\n    }\r\n\r\n    modifier onlyEOA() {\r\n        _checkEOA();\r\n        _;\r\n    }\r\n\r\n    function _checkEOA() internal view {\r\n        if (msg.sender != tx.origin || msg.sender.code.length \u003e 0) {\r\n            revert OnlyEOA();\r\n        }\r\n    }\r\n\r\n    function getToken() external view returns(uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] =  address(Token);\r\n        path[1] = address(USDT);\r\n        return getSwapRouterAmountsOut(path,AMPLIFIED_DECIMALS);\r\n    }\r\n\r\n\r\n    function register(address recommendedAddr) external onlyEOA() {\r\n        address user = _msgSender();\r\n        if(userRecommended[user] != address(0) || !allowRecommend[recommendedAddr]) {\r\n            revert RegisterInvalid(user,recommendedAddr);\r\n        }\r\n        userRecommended[user] = recommendedAddr;\r\n        directThrust[recommendedAddr].push(user);\r\n\r\n        emit Register(user, recommendedAddr, block.timestamp);\r\n    } \r\n\r\n    function buyCar(uint256 typeOf) external onlyEOA() {\r\n        address user = _msgSender();\r\n        if(typeOf \u003e 6 || typeOf == 0) {\r\n            revert(\"typeOf\");\r\n        }\r\n        if(userRecommended[user] == address(0)) {\r\n            revert(\"userRecommended\");\r\n        }    \r\n        if(userisBuyCarTypeOf[user][typeOf]) {\r\n            revert(\"userisBuyCarTypeOf\");\r\n        }\r\n        uint256 usdtAmount = carPrices[typeOf-1];\r\n        USDT.safeTransferFrom(user,address(this),usdtAmount);\r\n        allowRecommend[user] = true;\r\n        userisBuyCarTypeOf[user][typeOf] = true;\r\n        if(typeOf \u003e userMaxTypeOf[user]) {\r\n            userMaxTypeOf[user] = typeOf;\r\n        }\r\n        sendToken(user,usdtAmount,1);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(Token);\r\n                \r\n        swapTokensForTokens(path,usdtAmount/2,0,burnAddr);\r\n        USDT.safeTransfer(receiverAddress,USDT.balanceOf(address(this)));\r\n        \r\n        emit BuyCar(user,usdtAmount,typeOf,block.timestamp);\r\n    }\r\n\r\n    function raceCar(uint256 typeOf) external onlyEOA() {\r\n        address user = _msgSender();\r\n        if(typeOf \u003e 5 || typeOf == 0) {\r\n            revert(\"typeOf\");\r\n        } \r\n        if(userMaxTypeOf[user] == 0) {\r\n            revert(\"userMaxTypeOf\");\r\n        }\r\n        uint256 culDays = (block.timestamp - raceCarStartTime) / 1 days;\r\n        userRaceCarDayCount[user][culDays] += 1;\r\n        if(userRaceCarDayCount[user][culDays] \u003e raceCarMaxCount) {\r\n            revert(\"userRaceCarDayCount\");\r\n        }\r\n        uint256 usdtAmount = racePrices[typeOf - 1];\r\n        USDT.safeTransferFrom(user,receiverAddress,usdtAmount);\r\n        \r\n        emit RaceCar(user,usdtAmount,typeOf,block.timestamp);\r\n    }\r\n\r\n    function raceCarWin(address user, uint256 usdtAmount) external {\r\n        if(!allowRaceCarWin[_msgSender()]) {\r\n            revert(\"allowRaceCarWin\");\r\n        }\r\n        sendToken(user,usdtAmount,2);\r\n        USDT.safeTransferFrom(withdrawAddr,address(this),usdtAmount/2);\r\n        addLiquidityUsdt(usdtAmount/2); \r\n    }\r\n\r\n    function addGuild(uint256 guildType) external onlyEOA() {\r\n        address user = _msgSender();\r\n        if(userRecommended[user] == address(0)) {\r\n            revert(\"userRecommended\");\r\n        }  \r\n        if(guildType \u003e 3 || guildType == 0 || userGuildType[user] == guildType) {\r\n            revert(\"guildType\");\r\n        }\r\n        culGuildTypeByAddNum[guildType] ++;\r\n        if(culGuildTypeByAddNum[guildType] \u003e GuildTypeByMaxnum[guildType]) {\r\n            revert(\"culGuildTypeByAddNum\");\r\n        }\r\n        uint256 usdtA;\r\n        if(userGuildType[user] != 0 \u0026\u0026 userGuildType[user] \u003c guildType) {\r\n            culGuildTypeByAddNum[userGuildType[user]] --;\r\n        } \r\n        usdtA = GuildTypeByUsdt[guildType] - GuildTypeByUsdt[userGuildType[user]];\r\n        userGuildType[user] = guildType;\r\n\r\n        USDT.safeTransferFrom(user,receiverAddress,usdtA);\r\n\r\n        emit AddGuild(user,usdtA,guildType,block.timestamp);\r\n    }\r\n\r\n\r\n    function ownerSetGuild(address user,uint256 guildType) external {\r\n        if(!allowRaceCarWin[_msgSender()]) {\r\n            revert(\"allowRaceCarWin\");\r\n        }\r\n        if(userRecommended[user] == address(0)) {\r\n            revert(\"userRecommended\");\r\n        }  \r\n        if(guildType \u003e 3 || guildType == 0 || userGuildType[user] == guildType) {\r\n            revert(\"guildType\");\r\n        }\r\n        culGuildTypeByAddNum[guildType] ++;\r\n        if(culGuildTypeByAddNum[guildType] \u003e GuildTypeByMaxnum[guildType]) {\r\n            revert(\"culGuildTypeByAddNum\");\r\n        }\r\n        if(userGuildType[user] != 0 \u0026\u0026 userGuildType[user] \u003c guildType) {\r\n            culGuildTypeByAddNum[userGuildType[user]] --;\r\n        } \r\n        userGuildType[user] = guildType;\r\n\r\n        emit OwnerSetGuild(user,guildType,block.timestamp);\r\n    }\r\n\r\n    function sendToken(address user, uint256 value, uint256 sourceOf) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] =  address(Token);\r\n        path[1] = address(USDT);\r\n        uint256 culPrice = getSwapRouterAmountsOut(path,AMPLIFIED_DECIMALS);\r\n        uint256 amount = value * AMPLIFIED_DECIMALS / culPrice;\r\n        Token.safeTransfer(user,amount);\r\n\r\n        emit TokenSource(user,amount,sourceOf,block.timestamp);\r\n    }\r\n\r\n    function addLiquidityUsdt(uint256 usdtAmount) private {\r\n        addLiquidity(address(Token),address(USDT),Token.balanceOf(address(this)),usdtAmount,0,usdtAmount,burnAddr);\r\n    }\r\n\r\n    function setReceiverAddress(address receiverAddress_) external onlyOwner {\r\n        receiverAddress = receiverAddress_;\r\n    }\r\n\r\n    function setToken(address token_) external onlyOwner {\r\n        Token = IERC20(token_);\r\n        Token.approve(address(_IPancakeRouter), type(uint256).max);\r\n    }\r\n\r\n    function setAllowRaceCarWin(address addr_, bool enabl) external onlyOwner {\r\n        allowRaceCarWin[addr_] = enabl;\r\n    }\r\n\r\n    function setWithdrawAddr(address addr) external onlyOwner {\r\n        withdrawAddr = addr;\r\n\r\n        emit SetWithdrawAddr(addr, block.timestamp);\r\n    }\r\n\r\n    function setAllowanceWithdrawAddr(address addr, bool enabl) external onlyOwner {\r\n        allowanceWithdrawAddr[addr] = enabl;\r\n\r\n        emit SetAllowanceWithdrawAddr(addr,enabl,block.timestamp);\r\n    }\r\n\r\n    function setPrice(uint256[6] memory carPrices_, uint256[4] memory racePrices_, uint256[4] memory GuildTypeByUsdt_) external onlyOwner {\r\n        carPrices = carPrices_;\r\n        racePrices = racePrices_;\r\n        GuildTypeByUsdt = GuildTypeByUsdt_;\r\n    }\r\n\r\n    function setRaceCarMaxCount(uint256 raceCarMaxCount_) external onlyOwner {\r\n        raceCarMaxCount = raceCarMaxCount_;\r\n    }\r\n\r\n    function withdraw(address addr,uint256 amount) external {\r\n        if(allowanceWithdrawAddr[_msgSender()]) {\r\n            USDT.safeTransferFrom(withdrawAddr,addr, amount);\r\n\r\n            emit Withdraw(withdrawAddr,addr,amount,block.timestamp);\r\n        }\r\n    }\r\n\r\n    function withdrawToken(address addr,uint256 amount, address token_) external {\r\n        if(allowanceWithdrawAddr[_msgSender()]) {\r\n            IERC20(token_).safeTransfer(addr, amount);\r\n\r\n            emit Withdraw(withdrawAddr,addr,amount,block.timestamp);\r\n        }\r\n    }\r\n\r\n    function addUser(address[] memory users, address[] memory recommendedAddrs) external onlyOwner {\r\n        for(uint256 i = 0; i \u003c users.length; i++) {\r\n            userRecommended[users[i]] = recommendedAddrs[i];\r\n        }\r\n    }\r\n\r\n    function addUserBuyCar(address[] memory users, uint256[] memory typeOfs) external onlyOwner {\r\n        for(uint256 i = 0; i \u003c users.length; i++) {\r\n            allowRecommend[users[i]] = true;\r\n            userisBuyCarTypeOf[users[i]][typeOfs[i]] = true;\r\n        }\r\n    }\r\n\r\n    function addUserGuild(address[] memory users, uint256[] memory guildTypes) external onlyOwner {\r\n        for(uint256 i = 0; i \u003c users.length; i++) {\r\n            culGuildTypeByAddNum[guildTypes[i]] ++;\r\n            userGuildType[users[i]] = guildTypes[i];\r\n        }\r\n    }\r\n}\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\nimport {Context} from \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\nimport {IERC20} from \"./IERC20.sol\";\r\nimport {IERC1363} from \"./IERC1363.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    /**\r\n     * @dev An operation with an ERC-20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Indicates a failed `decreaseAllowance` request.\r\n     */\r\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract\u0027s allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     *\r\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\r\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\r\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\r\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        forceApprove(token, spender, oldAllowance + value);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract\u0027s allowance toward `spender` by `requestedDecrease`. If `token` returns no\r\n     * value, non-reverting calls are assumed to be successful.\r\n     *\r\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\r\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\r\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\r\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\r\n        unchecked {\r\n            uint256 currentAllowance = token.allowance(address(this), spender);\r\n            if (currentAllowance \u003c requestedDecrease) {\r\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\r\n            }\r\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract\u0027s allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     *\r\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\r\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\r\n     * set here.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\r\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\r\n     * targeting contracts.\r\n     *\r\n     * Reverts if the returned value is other than `true`.\r\n     */\r\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\r\n        if (to.code.length == 0) {\r\n            safeTransfer(token, to, value);\r\n        } else if (!token.transferAndCall(to, value, data)) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\r\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\r\n     * targeting contracts.\r\n     *\r\n     * Reverts if the returned value is other than `true`.\r\n     */\r\n    function transferFromAndCallRelaxed(\r\n        IERC1363 token,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) internal {\r\n        if (to.code.length == 0) {\r\n            safeTransferFrom(token, from, to, value);\r\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\r\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\r\n     * targeting contracts.\r\n     *\r\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\r\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\r\n     * once without retrying, and relies on the returned value to be true.\r\n     *\r\n     * Reverts if the returned value is other than `true`.\r\n     */\r\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\r\n        if (to.code.length == 0) {\r\n            forceApprove(token, to, value);\r\n        } else if (!token.approveAndCall(to, value, data)) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        uint256 returnSize;\r\n        uint256 returnValue;\r\n        assembly (\"memory-safe\") {\r\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\r\n            // bubble errors\r\n            if iszero(success) {\r\n                let ptr := mload(0x40)\r\n                returndatacopy(ptr, 0, returndatasize())\r\n                revert(ptr, returndatasize())\r\n            }\r\n            returnSize := returndatasize()\r\n            returnValue := mload(0)\r\n        }\r\n\r\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        bool success;\r\n        uint256 returnSize;\r\n        uint256 returnValue;\r\n        assembly (\"memory-safe\") {\r\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\r\n            returnSize := returndatasize()\r\n            returnValue := mload(0)\r\n        }\r\n        return success \u0026\u0026 (returnSize == 0 ? address(token).code.length \u003e 0 : returnValue == 1);\r\n    }\r\n}"}}