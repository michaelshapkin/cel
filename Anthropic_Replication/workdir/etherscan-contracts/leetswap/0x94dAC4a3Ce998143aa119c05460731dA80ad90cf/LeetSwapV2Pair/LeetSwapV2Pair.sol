{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"},"IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"ILeetSwapV2Callee.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILeetSwapV2Callee {\n    function hook(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}"},"ILeetSwapV2Factory.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface ILeetSwapV2Factory {\n    function allPairsLength() external view returns (uint256);\n\n    function isPair(address pair) external view returns (bool);\n\n    function pairCodeHash() external pure returns (bytes32);\n\n    function getPair(\n        address tokenA,\n        address token,\n        bool stable\n    ) external view returns (address);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address);\n\n    function getInitializable()\n        external\n        view\n        returns (\n            address token0,\n            address token1,\n            bool stable\n        );\n\n    function protocolFeesShare() external view returns (uint256);\n\n    function protocolFeesRecipient() external view returns (address);\n\n    function tradingFees(address pair, address to)\n        external\n        view\n        returns (uint256);\n\n    function isPaused() external view returns (bool);\n}"},"ILeetSwapV2Pair.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface ILeetSwapV2Pair {\n    function factory() external view returns (address);\n\n    function fees() external view returns (address);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        );\n\n    function getAmountOut(uint256, address) external view returns (uint256);\n\n    function current(address tokenIn, uint256 amountIn)\n        external\n        view\n        returns (uint256);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function stable() external view returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    //LP token pricing\n    function sample(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points,\n        uint256 window\n    ) external view returns (uint256[] memory);\n\n    function quote(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 granularity\n    ) external view returns (uint256);\n\n    function claimFeesFor(address account)\n        external\n        returns (uint256 claimed0, uint256 claimed1);\n\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1);\n\n    function claimableFeesFor(address account)\n        external\n        returns (uint256 claimed0, uint256 claimed1);\n\n    function claimableFees()\n        external\n        returns (uint256 claimed0, uint256 claimed1);\n}"},"LeetSwapV2Fees.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n// Base V1 Fees contract is used as a 1:1 pair relationship to split out fees, this ensures that the curve does not need to be modified for LP shares\ncontract LeetSwapV2Fees {\n    address internal immutable pair; // The pair it is bonded to\n    address internal immutable token0; // token0 of pair, saved localy and statically for gas optimization\n    address internal immutable token1; // Token1 of pair, saved localy and statically for gas optimization\n\n    error InvalidToken();\n    error TransferFailed();\n    error Unauthorized();\n\n    constructor(address _token0, address _token1) {\n        pair = msg.sender;\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        if (token.code.length == 0) revert InvalidToken();\n        bool success = IERC20(token).transfer(to, value);\n        if (!success) revert TransferFailed();\n    }\n\n    // Allow the pair to transfer fees to users\n    function claimFeesFor(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1\n    ) external {\n        if (msg.sender != pair) revert Unauthorized();\n        if (amount0 \u003e 0) _safeTransfer(token0, recipient, amount0);\n        if (amount1 \u003e 0) _safeTransfer(token1, recipient, amount1);\n    }\n}"},"LeetSwapV2Pair.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./LeetSwapV2Fees.sol\";\nimport \"./ILeetSwapV2Factory.sol\";\nimport \"./ILeetSwapV2Pair.sol\";\nimport \"./ILeetSwapV2Callee.sol\";\nimport \"./Math.sol\";\nimport \"./IERC20Metadata.sol\";\n\n// The base pair of pools, either stable or volatile\ncontract LeetSwapV2Pair is ILeetSwapV2Pair {\n    uint8 public constant decimals = 18;\n\n    // Used to denote stable or volatile pair, not immutable since construction happens in the initialize method for CREATE2 deterministic addresses\n    bool public immutable stable;\n\n    uint256 public totalSupply = 0;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n    mapping(address =\u003e uint256) public balanceOf;\n\n    bytes32 internal DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address =\u003e uint256) public nonces;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n\n    address public immutable token0;\n    address public immutable token1;\n    address public immutable fees;\n    address public immutable factory;\n\n    // Structure to capture time period observations every 30 minutes, used for local oracles\n    struct Observation {\n        uint256 timestamp;\n        uint256 reserve0Cumulative;\n        uint256 reserve1Cumulative;\n    }\n\n    // Capture oracle reading every 30 minutes\n    uint256 constant periodSize = 1800;\n\n    Observation[] public observations;\n\n    uint256 public reserve0;\n    uint256 public reserve1;\n    uint256 public blockTimestampLast;\n\n    uint256 public reserve0CumulativeLast;\n    uint256 public reserve1CumulativeLast;\n\n    // index0 and index1 are used to accumulate fees, this is split out from normal trades to keep the swap \"clean\"\n    // this further allows LP holders to easily claim fees for tokens they have/staked\n    uint256 public index0 = 0;\n    uint256 public index1 = 0;\n\n    // position assigned to each LP to track their current index0 \u0026 index1 vs the global position\n    mapping(address =\u003e uint256) public supplyIndex0;\n    mapping(address =\u003e uint256) public supplyIndex1;\n\n    // tracks the amount of unclaimed, but claimable tokens off of fees for token0 and token1\n    mapping(address =\u003e uint256) public claimable0;\n    mapping(address =\u003e uint256) public claimable1;\n\n    event Fees(address indexed sender, uint256 amount0, uint256 amount1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint256 reserve0, uint256 reserve1);\n    event Claim(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    error DEXPaused();\n    error InvalidToken();\n    error TransferFailed();\n    error InsufficientOutputAmount();\n    error InsufficientInputAmount();\n    error InsufficientLiquidity();\n    error ReentrancyGuard();\n    error DeadlineExpired();\n    error InsufficientLiquidityMinted();\n    error InsufficientLiquidityBurned();\n    error InvariantNotRespected();\n    error InvalidSwapRecipient();\n    error InvalidSignature();\n\n    constructor() {\n        factory = msg.sender;\n        (address _token0, address _token1, bool _stable) = ILeetSwapV2Factory(\n            msg.sender\n        ).getInitializable();\n        (token0, token1, stable) = (_token0, _token1, _stable);\n\n        fees = address(new LeetSwapV2Fees(_token0, _token1));\n\n        observations.push(Observation(block.timestamp, 0, 0));\n    }\n\n    function decimals0() internal view returns (uint256) {\n        return 10**IERC20Metadata(token0).decimals();\n    }\n\n    function decimals1() internal view returns (uint256) {\n        return 10**IERC20Metadata(token1).decimals();\n    }\n\n    function name() public view returns (string memory) {\n        if (stable) {\n            return\n                string(\n                    abi.encodePacked(\n                        \"LeetSwapV2 StableV1 Pair - \",\n                        IERC20Metadata(token0).symbol(),\n                        \"/\",\n                        IERC20Metadata(token1).symbol()\n                    )\n                );\n        }\n\n        return\n            string(\n                abi.encodePacked(\n                    \"LeetSwapV2 VolatileV1 Pair - \",\n                    IERC20Metadata(token0).symbol(),\n                    \"/\",\n                    IERC20Metadata(token1).symbol()\n                )\n            );\n    }\n\n    function symbol() public view returns (string memory) {\n        if (stable) {\n            return\n                string(\n                    abi.encodePacked(\n                        \"sLS2-\",\n                        IERC20Metadata(token0).symbol(),\n                        \"/\",\n                        IERC20Metadata(token1).symbol()\n                    )\n                );\n        }\n\n        return\n            string(\n                abi.encodePacked(\n                    \"vLS2-\",\n                    IERC20Metadata(token0).symbol(),\n                    \"/\",\n                    IERC20Metadata(token1).symbol()\n                )\n            );\n    }\n\n    // simple re-entrancy check\n    uint256 internal _unlocked = 1;\n    modifier lock() {\n        if (_unlocked != 1) revert ReentrancyGuard();\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function observationLength() external view returns (uint256) {\n        return observations.length;\n    }\n\n    function lastObservation() public view returns (Observation memory) {\n        return observations[observations.length - 1];\n    }\n\n    function metadata()\n        external\n        view\n        returns (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n            address t1\n        )\n    {\n        return (\n            decimals0(),\n            decimals1(),\n            reserve0,\n            reserve1,\n            stable,\n            token0,\n            token1\n        );\n    }\n\n    function tokens() external view returns (address, address) {\n        return (token0, token1);\n    }\n\n    // claim accumulated but unclaimed fees (viewable via claimable0 and claimable1)\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1) {\n        return claimFeesFor(msg.sender);\n    }\n\n    function claimFeesFor(address recipient)\n        public\n        lock\n        returns (uint256 claimed0, uint256 claimed1)\n    {\n        _updateFor(recipient);\n\n        claimed0 = claimable0[recipient];\n        claimed1 = claimable1[recipient];\n\n        claimable0[recipient] = 0;\n        claimable1[recipient] = 0;\n\n        LeetSwapV2Fees(fees).claimFeesFor(recipient, claimed0, claimed1);\n\n        emit Claim(msg.sender, recipient, claimed0, claimed1);\n    }\n\n    function claimableFeesFor(address account)\n        public\n        view\n        returns (uint256 _claimable0, uint256 _claimable1)\n    {\n        uint256 _supplied = balanceOf[account];\n        _claimable0 = claimable0[account];\n        _claimable1 = claimable1[account];\n        if (_supplied \u003e 0) {\n            uint256 _delta0 = index0 - supplyIndex0[account];\n            uint256 _delta1 = index1 - supplyIndex1[account];\n            if (_delta0 \u003e 0) {\n                uint256 _share = (_supplied * _delta0) / 1e18;\n                _claimable0 += _share;\n            }\n            if (_delta1 \u003e 0) {\n                uint256 _share = (_supplied * _delta1) / 1e18;\n                _claimable1 += _share;\n            }\n        }\n    }\n\n    function claimableFees()\n        external\n        view\n        returns (uint256 _claimable0, uint256 _claimable1)\n    {\n        return claimableFeesFor(msg.sender);\n    }\n\n    // Used to transfer fees when calling _update[01]\n    function _transferFeesSupportingTaxTokens(address token, uint256 amount)\n        public\n        returns (uint256)\n    {\n        if (amount == 0) {\n            return 0;\n        }\n\n        uint256 balanceBefore = IERC20(token).balanceOf(fees);\n        _safeTransfer(token, fees, amount);\n        uint256 balanceAfter = IERC20(token).balanceOf(fees);\n\n        return balanceAfter - balanceBefore;\n    }\n\n    // Accrue fees on token0\n    function _update0(uint256 amount) internal {\n        uint256 _protocolFeesShare = ILeetSwapV2Factory(factory)\n            .protocolFeesShare();\n        address _protocolFeesRecipient = ILeetSwapV2Factory(factory)\n            .protocolFeesRecipient();\n        uint256 _protocolFeesAmount = (amount * _protocolFeesShare) / 10000;\n        amount = _transferFeesSupportingTaxTokens(\n            token0,\n            amount - _protocolFeesAmount\n        );\n        if (_protocolFeesAmount \u003e 0)\n            _safeTransfer(token0, _protocolFeesRecipient, _protocolFeesAmount);\n        uint256 _ratio = (amount * 1e18) / totalSupply;\n        if (_ratio \u003e 0) {\n            index0 += _ratio;\n        }\n        emit Fees(msg.sender, amount, 0);\n    }\n\n    // Accrue fees on token1\n    function _update1(uint256 amount) internal {\n        uint256 _protocolFeesShare = ILeetSwapV2Factory(factory)\n            .protocolFeesShare();\n        address _protocolFeesRecipient = ILeetSwapV2Factory(factory)\n            .protocolFeesRecipient();\n        uint256 _protocolFeesAmount = (amount * _protocolFeesShare) / 10000;\n        amount = _transferFeesSupportingTaxTokens(\n            token1,\n            amount - _protocolFeesAmount\n        );\n        if (_protocolFeesAmount \u003e 0)\n            _safeTransfer(token1, _protocolFeesRecipient, _protocolFeesAmount);\n        uint256 _ratio = (amount * 1e18) / totalSupply;\n        if (_ratio \u003e 0) {\n            index1 += _ratio;\n        }\n        emit Fees(msg.sender, 0, amount);\n    }\n\n    // this function MUST be called on any balance changes, otherwise can be used to infinitely claim fees\n    // Fees are segregated from core funds, so fees can never put liquidity at risk\n    function _updateFor(address recipient) internal {\n        uint256 _supplied = balanceOf[recipient]; // get LP balance of `recipient`\n        if (_supplied \u003e 0) {\n            uint256 _supplyIndex0 = supplyIndex0[recipient]; // get last adjusted index0 for recipient\n            uint256 _supplyIndex1 = supplyIndex1[recipient];\n            uint256 _index0 = index0; // get global index0 for accumulated fees\n            uint256 _index1 = index1;\n            supplyIndex0[recipient] = _index0; // update user current position to global position\n            supplyIndex1[recipient] = _index1;\n            uint256 _delta0 = _index0 - _supplyIndex0; // see if there is any difference that need to be accrued\n            uint256 _delta1 = _index1 - _supplyIndex1;\n            if (_delta0 \u003e 0) {\n                uint256 _share = (_supplied * _delta0) / 1e18; // add accrued difference for each supplied token\n                claimable0[recipient] += _share;\n            }\n            if (_delta1 \u003e 0) {\n                uint256 _share = (_supplied * _delta1) / 1e18;\n                claimable1[recipient] += _share;\n            }\n        } else {\n            supplyIndex0[recipient] = index0; // new users are set to the default global state\n            supplyIndex1[recipient] = index1;\n        }\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal {\n        uint256 blockTimestamp = block.timestamp;\n        uint256 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed \u003e 0 \u0026\u0026 _reserve0 != 0 \u0026\u0026 _reserve1 != 0) {\n            reserve0CumulativeLast += _reserve0 * timeElapsed;\n            reserve1CumulativeLast += _reserve1 * timeElapsed;\n        }\n\n        Observation memory _point = lastObservation();\n        timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event\n        if (timeElapsed \u003e periodSize) {\n            observations.push(\n                Observation(\n                    blockTimestamp,\n                    reserve0CumulativeLast,\n                    reserve1CumulativeLast\n                )\n            );\n        }\n        reserve0 = balance0;\n        reserve1 = balance1;\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices()\n        public\n        view\n        returns (\n            uint256 reserve0Cumulative,\n            uint256 reserve1Cumulative,\n            uint256 blockTimestamp\n        )\n    {\n        blockTimestamp = block.timestamp;\n        reserve0Cumulative = reserve0CumulativeLast;\n        reserve1Cumulative = reserve1CumulativeLast;\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        ) = getReserves();\n        if (_blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint256 timeElapsed = blockTimestamp - _blockTimestampLast;\n            reserve0Cumulative += _reserve0 * timeElapsed;\n            reserve1Cumulative += _reserve1 * timeElapsed;\n        }\n    }\n\n    // gives the current twap price measured from amountIn * tokenIn gives amountOut\n    function current(address tokenIn, uint256 amountIn)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        Observation memory _observation = lastObservation();\n        (\n            uint256 reserve0Cumulative,\n            uint256 reserve1Cumulative,\n\n        ) = currentCumulativePrices();\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[observations.length - 2];\n        }\n\n        uint256 timeElapsed = block.timestamp - _observation.timestamp;\n        uint256 _reserve0 = (reserve0Cumulative -\n            _observation.reserve0Cumulative) / timeElapsed;\n        uint256 _reserve1 = (reserve1Cumulative -\n            _observation.reserve1Cumulative) / timeElapsed;\n        amountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    // as per `current`, however allows user configured granularity, up to the full window size\n    function quote(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 granularity\n    ) external view returns (uint256 amountOut) {\n        uint256[] memory _prices = sample(tokenIn, amountIn, granularity, 1);\n        uint256 priceAverageCumulative;\n        for (uint256 i = 0; i \u003c _prices.length; i++) {\n            priceAverageCumulative += _prices[i];\n        }\n        return priceAverageCumulative / granularity;\n    }\n\n    // returns a memory set of twap prices\n    function prices(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points\n    ) external view returns (uint256[] memory) {\n        return sample(tokenIn, amountIn, points, 1);\n    }\n\n    function sample(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points,\n        uint256 window\n    ) public view returns (uint256[] memory) {\n        uint256[] memory _prices = new uint256[](points);\n\n        uint256 length = observations.length - 1;\n        uint256 i = length - (points * window);\n        uint256 nextIndex = 0;\n        uint256 index = 0;\n\n        for (; i \u003c length; i += window) {\n            nextIndex = i + window;\n            uint256 timeElapsed = observations[nextIndex].timestamp -\n                observations[i].timestamp;\n            uint256 _reserve0 = (observations[nextIndex].reserve0Cumulative -\n                observations[i].reserve0Cumulative) / timeElapsed;\n            uint256 _reserve1 = (observations[nextIndex].reserve1Cumulative -\n                observations[i].reserve1Cumulative) / timeElapsed;\n            _prices[index] = _getAmountOut(\n                amountIn,\n                tokenIn,\n                _reserve0,\n                _reserve1\n            );\n            index = index + 1;\n        }\n        return _prices;\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    // standard uniswap v2 implementation\n    function mint(address to) external lock returns (uint256 liquidity) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        uint256 _balance0 = IERC20Metadata(token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20Metadata(token1).balanceOf(address(this));\n        uint256 _amount0 = _balance0 - _reserve0;\n        uint256 _amount1 = _balance1 - _reserve1;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(\n                (_amount0 * _totalSupply) / _reserve0,\n                (_amount1 * _totalSupply) / _reserve1\n            );\n        }\n        if (liquidity \u003c= 0) revert InsufficientLiquidityMinted();\n        _mint(to, liquidity);\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, _amount0, _amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    // standard uniswap v2 implementation\n    function burn(address to)\n        external\n        lock\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        (address _token0, address _token1) = (token0, token1);\n        uint256 _balance0 = IERC20Metadata(_token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20Metadata(_token1).balanceOf(address(this));\n        uint256 _liquidity = balanceOf[address(this)];\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = (_liquidity * _balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = (_liquidity * _balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        if (amount0 \u003c= 0 || amount1 \u003c= 0) revert InsufficientLiquidityBurned();\n        _burn(address(this), _liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        _balance0 = IERC20Metadata(_token0).balanceOf(address(this));\n        _balance1 = IERC20Metadata(_token1).balanceOf(address(this));\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock {\n        if (ILeetSwapV2Factory(factory).isPaused()) revert DEXPaused();\n        if (amount0Out \u003c= 0 \u0026\u0026 amount1Out \u003c= 0)\n            revert InsufficientOutputAmount();\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        if (amount0Out \u003e= _reserve0 || amount1Out \u003e= _reserve1)\n            revert InsufficientLiquidity();\n\n        uint256 _balance0;\n        uint256 _balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            if (to == _token0 || to == _token1) revert InvalidSwapRecipient();\n            if (amount0Out \u003e 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out \u003e 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length \u003e 0)\n                ILeetSwapV2Callee(to).hook(\n                    msg.sender,\n                    amount0Out,\n                    amount1Out,\n                    data\n                ); // callback, used for flash loans\n            _balance0 = IERC20Metadata(_token0).balanceOf(address(this));\n            _balance1 = IERC20Metadata(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = _balance0 \u003e _reserve0 - amount0Out\n            ? _balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint256 amount1In = _balance1 \u003e _reserve1 - amount1Out\n            ? _balance1 - (_reserve1 - amount1Out)\n            : 0;\n        if (amount0In \u003c= 0 \u0026\u0026 amount1In \u003c= 0) revert InsufficientInputAmount();\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            uint256 _tradingFees = ILeetSwapV2Factory(factory).tradingFees(\n                address(this),\n                to\n            );\n            if (amount0In \u003e 0) _update0((amount0In * _tradingFees) / 10000); // accrue fees for token0 and move them out of pool\n            if (amount1In \u003e 0) _update1((amount1In * _tradingFees) / 10000); // accrue fees for token1 and move them out of pool\n            _balance0 = IERC20Metadata(_token0).balanceOf(address(this)); // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - amountIn/ 10000, but doing balanceOf again as safety check\n            _balance1 = IERC20Metadata(_token1).balanceOf(address(this));\n            // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\n            if (_k(_balance0, _balance1) \u003c _k(_reserve0, _reserve1))\n                revert InvariantNotRespected();\n        }\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        (address _token0, address _token1) = (token0, token1);\n        _safeTransfer(\n            _token0,\n            to,\n            IERC20Metadata(_token0).balanceOf(address(this)) - (reserve0)\n        );\n        _safeTransfer(\n            _token1,\n            to,\n            IERC20Metadata(_token1).balanceOf(address(this)) - (reserve1)\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(\n            IERC20Metadata(token0).balanceOf(address(this)),\n            IERC20Metadata(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return\n            (x0 * ((((y * y) / 1e18) * y) / 1e18)) /\n            1e18 +\n            (((((x0 * x0) / 1e18) * x0) / 1e18) * y) /\n            1e18;\n    }\n\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return\n            (3 * x0 * ((y * y) / 1e18)) /\n            1e18 +\n            ((((x0 * x0) / 1e18) * x0) / 1e18);\n    }\n\n    function _get_y(\n        uint256 x0,\n        uint256 xy,\n        uint256 y\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i \u003c 255; i++) {\n            uint256 y_prev = y;\n            uint256 k = _f(x0, y);\n            if (k \u003c xy) {\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\n                y = y + dy;\n            } else {\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\n                y = y - dy;\n            }\n            if (y \u003e y_prev) {\n                if (y - y_prev \u003c= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y \u003c= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        address to\n    ) public view returns (uint256) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        uint256 _tradingFees = ILeetSwapV2Factory(factory).tradingFees(\n            address(this),\n            to\n        );\n        amountIn -= (amountIn * _tradingFees) / 10000; // remove fee from amount received\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function getAmountOut(uint256 amountIn, address tokenIn)\n        external\n        view\n        returns (uint256)\n    {\n        return getAmountOut(amountIn, tokenIn, msg.sender);\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256) {\n        if (stable) {\n            uint256 xy = _k(_reserve0, _reserve1);\n            _reserve0 = (_reserve0 * 1e18) / decimals0();\n            _reserve1 = (_reserve1 * 1e18) / decimals1();\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0\n                ? (amountIn * 1e18) / decimals0()\n                : (amountIn * 1e18) / decimals1();\n            uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\n            return (y * (tokenIn == token0 ? decimals1() : decimals0())) / 1e18;\n        } else {\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            return (amountIn * reserveB) / (reserveA + amountIn);\n        }\n    }\n\n    function _k(uint256 x, uint256 y) internal view returns (uint256) {\n        if (stable) {\n            uint256 _x = (x * 1e18) / decimals0();\n            uint256 _y = (y * 1e18) / decimals1();\n            uint256 _a = (_x * _y) / 1e18;\n            uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            return (_a * _b) / 1e18; // x3y+y3x \u003e= k\n        } else {\n            return x * y; // xy \u003e= k\n        }\n    }\n\n    function _mint(address dst, uint256 amount) internal {\n        _updateFor(dst); // balances must be updated on mint/burn/transfer\n        totalSupply += amount;\n        balanceOf[dst] += amount;\n        emit Transfer(address(0), dst, amount);\n    }\n\n    function _burn(address dst, uint256 amount) internal {\n        _updateFor(dst);\n        totalSupply -= amount;\n        balanceOf[dst] -= amount;\n        emit Transfer(dst, address(0), amount);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        if (deadline \u003c block.timestamp) revert DeadlineExpired();\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name())),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        if (recoveredAddress == address(0) || recoveredAddress != owner)\n            revert InvalidSignature();\n        allowance[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowance[src][spender];\n\n        if (spender != src \u0026\u0026 spenderAllowance != type(uint256).max) {\n            uint256 newAllowance = spenderAllowance - amount;\n            allowance[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    function _transferTokens(\n        address src,\n        address dst,\n        uint256 amount\n    ) internal {\n        _updateFor(src); // update fee position for src\n        _updateFor(dst); // update fee position for dst\n\n        balanceOf[src] -= amount;\n        balanceOf[dst] += amount;\n\n        emit Transfer(src, dst, amount);\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        if (token.code.length == 0) revert InvalidToken();\n        bool success = IERC20(token).transfer(to, value);\n        if (!success) revert TransferFailed();\n    }\n}"},"Math.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Math {\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y \u003e 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x \u003c z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}"}}