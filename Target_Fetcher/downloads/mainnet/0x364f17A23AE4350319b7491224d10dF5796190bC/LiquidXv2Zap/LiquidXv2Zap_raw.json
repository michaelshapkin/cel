{{
  "language": "Solidity",
  "sources": {
    "/contracts/LiquidXv2Zap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface ILiquidXv2Router01 {\r\n  function factory() external view returns (address);\r\n  function WETH() external view returns (address);\r\n\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint amountADesired,\r\n    uint amountBDesired,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountA, uint amountB, uint liquidity);\r\n  function addLiquidityETH(\r\n    address token,\r\n    uint amountTokenDesired,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint liquidity,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETH(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function removeLiquidityWithPermit(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint liquidity,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETHWithPermit(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function swapExactTokensForTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapTokensForExactTokens(\r\n    uint amountOut,\r\n    uint amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IRewarderv2 {\r\n  function getReward(address account, address token) external view returns(uint256);\r\n  function claim(address account, address token) external;\r\n}\r\n\r\ninterface ILiquidXv2Factory {\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface ILiquidXv2Pair {\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface IERC20 {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function decimals() external view returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWETH {\r\n  function deposit() external payable;\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function withdraw(uint) external;\r\n}\r\n\r\ninterface IERC20Mint is IERC20 {\r\n  function mint(address account, uint256 amount) external;\r\n  function burn(address account, uint256 amount) external;\r\n}\r\n\r\ninterface IERC20Permit {\r\n  function permit(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n  function nonces(address owner) external view returns (uint256);\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    return account.code.length > 0;\r\n  }\r\n\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n    (bool success, ) = recipient.call{value: amount}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }\r\n\r\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n  }\r\n\r\n  function functionCall(\r\n      address target,\r\n      bytes memory data,\r\n      string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n      return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  function functionCallWithValue(\r\n      address target,\r\n      bytes memory data,\r\n      uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n  }\r\n\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n  }\r\n\r\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n  }\r\n\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n  }\r\n\r\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n  }\r\n\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n  }\r\n\r\n  function verifyCallResultFromTarget(\r\n    address target,\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    if (success) {\r\n      if (returndata.length == 0) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n      }\r\n      return returndata;\r\n    } else {\r\n      _revert(returndata, errorMessage);\r\n    }\r\n  }\r\n\r\n  function verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      _revert(returndata, errorMessage);\r\n    }\r\n  }\r\n\r\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n    if (returndata.length > 0) {\r\n      assembly {\r\n        let returndata_size := mload(returndata)\r\n        revert(add(32, returndata), returndata_size)\r\n      }\r\n    } else {\r\n      revert(errorMessage);\r\n    }\r\n  }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n  }\r\n\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    require(\r\n      (value == 0) || (token.allowance(address(this), spender) == 0),\r\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n    );\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    unchecked {\r\n      uint256 oldAllowance = token.allowance(address(this), spender);\r\n      require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n      uint256 newAllowance = oldAllowance - value;\r\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n  }\r\n\r\n  function safePermit(\r\n    IERC20Permit token,\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal {\r\n    uint256 nonceBefore = token.nonces(owner);\r\n    token.permit(owner, spender, value, deadline, v, r, s);\r\n    uint256 nonceAfter = token.nonces(owner);\r\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n  }\r\n\r\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n    if (returndata.length > 0) {\r\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n  }\r\n}\r\n\r\ninterface ISwapPlusv1 {\r\n  struct swapRouter {\r\n    string platform;\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint256 amountOutMin;\r\n    uint256 meta; // fee, flag(stable), 0=v2\r\n    uint256 percent;\r\n  }\r\n  struct swapLine {\r\n    swapRouter[] swaps;\r\n  }\r\n  struct swapBlock {\r\n    swapLine[] lines;\r\n  }\r\n\r\n  function swap(address tokenIn, uint256 amount, address tokenOut, address recipient, swapBlock[] calldata swBlocks) external payable returns(uint256, uint256);\r\n}\r\n\r\ncontract LiquidXv2Zap {\r\n  using SafeERC20 for IERC20;\r\n\r\n  address public router;\r\n  address public factory;\r\n  address public swapPlus;\r\n  address public wrappedETH;\r\n  address public rewarder;\r\n\r\n  mapping (address => bool) public operators;\r\n  address public operatorSetter;\r\n\r\n  // account => pair => basketId\r\n  mapping (address => mapping(address => mapping(uint256 => uint256))) public balanceOf;\r\n\r\n  struct swapPath {\r\n    ISwapPlusv1.swapBlock[] path;\r\n  }\r\n\r\n  event Deposit(address account, address token0, address token1, uint256 basketId, uint256 amount);\r\n  event Withdraw(address account, address token0, address token1, uint256 basketId, uint256 amount);\r\n\r\n  receive() external payable {\r\n  }\r\n\r\n  constructor(address _router, address _swapPlus, address _rewarder, address _wrappedETH) {\r\n    router = _router;\r\n    factory = ILiquidXv2Router01(_router).factory();\r\n    swapPlus = _swapPlus;\r\n    wrappedETH = _wrappedETH;\r\n    rewarder = _rewarder;\r\n    operatorSetter = msg.sender;\r\n  }\r\n\r\n  modifier onlyOpertaor() {\r\n    require(operators[msg.sender], \"LiquidXv2Zap: !operator\");\r\n    _;\r\n  }\r\n\r\n  function deposit(address account, address token, address tokenM, swapPath calldata path, address token0, address token1, uint256[3] calldata amount, uint256 basketId) public payable returns(uint256) {\r\n    address pair = ILiquidXv2Factory(factory).getPair(token0, token1);\r\n    require(pair != address(0), \"LiquidXv2Zap: no pair\");\r\n\r\n    // retAddLp 0, 1, 2\r\n    // inAmount\r\n    // token0Amount, token1Amount\r\n    uint256[6] memory lvar;\r\n    lvar[3] = msg.value;\r\n    address inToken = token;\r\n    if (token != address(0)) {\r\n      lvar[3] = IERC20(token).balanceOf(address(this));\r\n      IERC20(token).safeTransferFrom(account, address(this), amount[0]);\r\n      lvar[3] = IERC20(token).balanceOf(address(this)) - lvar[3];\r\n    }\r\n    else {\r\n      inToken = wrappedETH;\r\n      IWETH(wrappedETH).deposit{value: lvar[3]}();\r\n    }\r\n\r\n    if (path.path.length > 0) {\r\n      _approveTokenIfNeeded(inToken, swapPlus, lvar[3]);\r\n      (, lvar[3]) = ISwapPlusv1(swapPlus).swap(inToken, lvar[3], tokenM, address(this), path.path);\r\n      inToken = tokenM;\r\n    }\r\n\r\n    (lvar[4], lvar[5]) = _depositSwap(token0, token1, inToken, lvar[3]);\r\n\r\n    (lvar[0], lvar[1], lvar[2]) = ILiquidXv2Router01(router).addLiquidity(token0, token1, lvar[4], lvar[5], amount[1], amount[2], address(this), block.timestamp);\r\n    _refundReserveToken(account, token0, token1, lvar[4]-lvar[0], lvar[5]-lvar[1]);\r\n    if (basketId == 0) {\r\n      IERC20(pair).safeTransfer(account, lvar[2]);\r\n    }\r\n    else {\r\n      _addBalance(account, pair, basketId, lvar[2]);\r\n    }\r\n\r\n    if (rewarder != address(0) && IRewarderv2(rewarder).getReward(account, pair) > 0) {\r\n      IRewarderv2(rewarder).claim(account, pair);\r\n    }\r\n\r\n    emit Deposit(account, token0, token1, basketId, lvar[2]);\r\n    return lvar[2];\r\n  }\r\n\r\n  function withdraw(address account, address token0, address token1, uint256 amount, address tokenOut, uint256 basketId, address tokenM, swapPath calldata wpath, uint256[3] memory amountMin) public returns(uint256) {\r\n    address pair = ILiquidXv2Factory(factory).getPair(token0, token1);\r\n    require(pair != address(0), \"LiquidXv2Zap: no pair\");\r\n\r\n    if (basketId == 0) {\r\n      IERC20(pair).safeTransferFrom(account, address(this), amount);\r\n    }\r\n    else {\r\n      require(account == msg.sender || operators[msg.sender], \"LiquidXv2Zap: no access\");\r\n      if (balanceOf[account][pair][basketId] < amount) {\r\n        amount = balanceOf[account][pair][basketId];\r\n      }\r\n      balanceOf[account][pair][basketId] -= amount;\r\n    }\r\n\r\n    if (amount == 0) return 0;\r\n\r\n    _approveTokenIfNeeded(pair, router, amount);\r\n    // amount0, 1\r\n    // outAmount\r\n    uint256[3] memory vamount;\r\n    (vamount[0], vamount[1]) = ILiquidXv2Router01(router).removeLiquidity(token0, token1, amount, amountMin[0], amountMin[1], address(this), block.timestamp);\r\n\r\n    address tOut = tokenOut; \r\n    if (tokenOut == address(0)) {\r\n      tOut = wrappedETH;\r\n    }\r\n\r\n    vamount[2] = 0;\r\n    if (tOut == token1) {\r\n      vamount[2] = vamount[1];\r\n      _approveTokenIfNeeded(token0, router, vamount[0]);\r\n      address[] memory path = new address[](2);\r\n      path[0] = token0;\r\n      path[1] = token1;\r\n      uint256[] memory ret = ILiquidXv2Router01(router).swapExactTokensForTokens(vamount[0], amountMin[2], path, address(this), block.timestamp);\r\n      vamount[2] += ret[1];\r\n    }\r\n    else {\r\n      vamount[2] = vamount[0];\r\n      _approveTokenIfNeeded(token1, router, vamount[1]);\r\n      address[] memory path = new address[](2);\r\n      path[0] = token1;\r\n      path[1] = token0;\r\n      uint256[] memory ret = ILiquidXv2Router01(router).swapExactTokensForTokens(vamount[1], amountMin[2], path, address(this), block.timestamp);\r\n      vamount[2] += ret[1];\r\n    }\r\n\r\n    if (wpath.path.length > 0) {\r\n      _approveTokenIfNeeded(tokenOut, swapPlus, vamount[2]);\r\n      (, vamount[2]) = ISwapPlusv1(swapPlus).swap(tokenOut, vamount[2], tokenM==address(0)?wrappedETH:tokenM, address(this), wpath.path);\r\n      tokenOut = tokenM;\r\n    }\r\n\r\n    if (tokenOut != address(0)) {\r\n      IERC20(tokenOut).safeTransfer(account, vamount[2]);\r\n    }\r\n    else {\r\n      IWETH(wrappedETH).withdraw(vamount[2]);\r\n      (bool success, ) = payable(account).call{value: vamount[2]}(\"\");\r\n      require(success, \"LiquidXv2Zap: Failed withdraw\");\r\n    }\r\n\r\n    if (rewarder != address(0) && IRewarderv2(rewarder).getReward(account, pair) > 0) {\r\n      IRewarderv2(rewarder).claim(account, pair);\r\n    }\r\n\r\n    emit Withdraw(account, token0, token1, basketId, amount);\r\n    return vamount[2];\r\n  }\r\n\r\n  function _depositSwap(address token0, address token1, address inToken, uint256 inAmount) internal returns(uint256, uint256) {\r\n    address pair = ILiquidXv2Factory(factory).getPair(token0, token1);\r\n\r\n    bool isToken0 = false;\r\n    address outToken = token0;\r\n    uint256 reserve = 0;\r\n    if (inToken == token0) {\r\n      isToken0 = true;\r\n      outToken = token1;\r\n      (reserve, , ) = ILiquidXv2Pair(pair).getReserves();\r\n    }\r\n    else {\r\n      (, reserve, ) = ILiquidXv2Pair(pair).getReserves();\r\n    }\r\n\r\n    _approveTokenIfNeeded(inToken, router, inAmount);\r\n    uint256 swapAmount = _calculateSwapAmount(reserve, inAmount);\r\n\r\n    address[] memory path = new address[](2);\r\n    path[0] = inToken;\r\n    path[1] = outToken;\r\n    uint256[] memory ret = ILiquidXv2Router01(router).swapExactTokensForTokens(swapAmount, 0, path, address(this), block.timestamp);\r\n    inAmount = inAmount - ret[0];\r\n\r\n    _approveTokenIfNeeded(outToken, router, ret[1]);\r\n\r\n    if (isToken0) {\r\n      return (inAmount, ret[1]);\r\n    }\r\n    else {\r\n      return (ret[1], inAmount);\r\n    }\r\n  }\r\n\r\n  function _refundReserveToken(address account, address token0, address token1, uint256 amount0, uint256 amount1) internal {\r\n    if (amount0 > 0) {\r\n      IERC20(token0).safeTransfer(account, amount0);\r\n    }\r\n    if (amount1 > 0) {\r\n      IERC20(token1).safeTransfer(account, amount1);\r\n    }\r\n  }\r\n\r\n  function _calculateSwapAmount(uint256 reserve, uint256 inAmount) internal pure returns(uint256) {\r\n    // (sqrt(reserve^2*(1+C)^2 + 4C*reserve*inAmount) - reserve*(1+C)) / 2C\r\n    uint256 a1 = reserve * reserve * 1997 *1997;\r\n    uint256 a2 = 4 * 997 * reserve * inAmount * 1000;\r\n    return (_sqrt(a1+a2) - reserve * 1997) / (2 * 997);\r\n  }\r\n\r\n  function _sqrt(uint x) internal pure returns (uint y) {\r\n    uint z = (x + 1) / 2;\r\n    y = x;\r\n    while (z < y) {\r\n      y = z;\r\n      z = (x / z + z) / 2;\r\n    }\r\n  }\r\n\r\n  function _addBalance(address account, address pair, uint256 basketId, uint256 amount) internal {\r\n    balanceOf[account][pair][basketId] += amount;\r\n  }\r\n\r\n  function withdrawToken(address token, address target, uint256 amount) public onlyOpertaor {\r\n    if (token == address(0)) {\r\n      (bool success, ) = payable(target).call{value: amount}(\"\");\r\n      require(success, \"LiquidXv2Zap: Failed withdraw\");\r\n    }\r\n    else {\r\n      IERC20(token).safeTransfer(target, amount);\r\n    }\r\n  }\r\n\r\n  function setRouterAndFactory(address _router) public {\r\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\r\n    router = _router;\r\n    factory = ILiquidXv2Router01(_router).factory();\r\n  }\r\n\r\n  function setSwapPlus(address _swapPlus) public {\r\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\r\n    swapPlus = _swapPlus;\r\n  }\r\n\r\n  function setRewarder(address _rewarder) public {\r\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\r\n    rewarder = _rewarder;\r\n  }\r\n\r\n  function setOperator(address _operator, bool mode) external {\r\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\r\n    operators[_operator] = mode;\r\n  }\r\n\r\n  function setOperatorSetter(address _operatorSetter) external {\r\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\r\n    operatorSetter = _operatorSetter;\r\n  }\r\n\r\n  function _approveTokenIfNeeded(address token, address spender, uint256 amount) private {\r\n    uint256 oldAllowance = IERC20(token).allowance(address(this), spender);\r\n    if (oldAllowance < amount) {\r\n      if (oldAllowance > 0) {\r\n        IERC20(token).safeApprove(spender, 0);\r\n      }\r\n      IERC20(token).safeApprove(spender, type(uint256).max);\r\n    }\r\n  }\r\n}"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}