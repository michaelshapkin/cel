{{
  "language": "Solidity",
  "sources": {
    "/contracts/bsc/IntrospectionToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.19;\n\nimport \"./BEP20.sol\";\nimport \"./BEP20Detailed.sol\";\n\ncontract IntrospectionToken is BEP20, BEP20Detailed {\n\n    bool public airdropOpen = true;\n    bool public restoringAirdropOpen = true;\n    bool public initialMintHappened = false;\n    \n    constructor () BEP20Detailed(\"IntrospectionToken\", \"IT\", 18) {\n        _owner = msg.sender;\n        addToTotallyUnlockedAddresses(_owner);\n        addToTotallyUnlockedAddresses(address(this));\n        // _mint(_owner, 1050000 * (10 ** uint256(decimals())));\n    }\n    \n    function setParams(address exchangeAddress, address routerAddress, address _factoryAddress, address referralProgramAddress, address triggerWalletAddress) public onlyOwner returns (bool) {\n        require(address(exchange) == address(0), \"Params already set\");\n        exchange = IPankakeSwapExchange(exchangeAddress);\n        referralProgram = IReferralProgram(referralProgramAddress);\n        router = IPankakeSwapRouter(routerAddress);\n        factoryAddress = _factoryAddress;\n        addToTotallyUnlockedAddresses(exchangeAddress);\n        addToExchangesAddresses(exchangeAddress);\n        addContractToAllowed(exchangeAddress);\n        _triggerWalletAddress = triggerWalletAddress;\n        if(address(this) == exchange.token0()){\n            usdtToken = IBEP20(exchange.token1());\n        } else {\n            usdtToken = IBEP20(exchange.token0());\n        }\n        return true;\n    }\n\n    function airdrop(address to, uint256 amount) public onlyOwner returns (bool){\n        require(airdropOpen, \"Airdrop already closed\");\n        _mint(to, amount);\n        if(_firstBuyRates[to] == 0){\n            _firstBuyRates[to] = getUsdtRate();\n        }\n        return true;\n    }\n\n    function closeAirdrop() public onlyOwner returns (bool){\n        require(airdropOpen, \"Airdrop already closed\");\n        airdropOpen = false;\n        return true;\n    }\n\n\n    function restoringAirdrop(address to, uint256 amount, uint256 firstBuyRate, uint256 referralUnlock, bool _isActivated, uint256 incomingAmount, uint256 outgoingAmount) public onlyOwner returns (bool){\n        require(restoringAirdropOpen, \"Airdrop already closed\");\n        _mint(to, amount);\n        _firstBuyRates[to] = firstBuyRate;\n        _referralUnlocks[to] = referralUnlock;\n        isActivated[to] = _isActivated;\n        _totalIncomingTransfersAmounts[to] = incomingAmount;\n        _totalOutgoingTransfersAmounts[to] = outgoingAmount;\n        return true;\n    }\n\n    function closeRestoringAirdrop() public onlyOwner returns (bool){\n        require(restoringAirdropOpen, \"Airdrop already closed\");\n        restoringAirdropOpen = false;\n        return true;\n    }\n\n    \n    function burn(uint256 amount) public onlyOwner returns (bool){\n        _burn(msg.sender, amount);\n        return true;\n    }\n\n    function mintOnce(uint256 amount) public onlyOwner returns (bool){\n        require(!initialMintHappened, \"Initial mint already happened\");\n        initialMintHappened = true;\n        _mint(msg.sender, amount);\n        return true;\n    }\n\n    function burnOnSmartContractAddress(uint256 amount, address contractAddress) public onlyOwner returns (bool){\n        require(isContract(address(contractAddress)), \"Address is not a smart contract\");\n        _burn(contractAddress, amount);\n        exchange.sync();\n        updateCurrMaxUsdtRateIfNeeded();\n        return true;\n    }\n    \n}\n"
    },
    "/contracts/bsc/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "/contracts/bsc/IBEP20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the BEP20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {BEP20Detailed}.\n */\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "/contracts/bsc/BEP20Detailed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.19;\n\nimport \"./IBEP20.sol\";\n\n/**\n * @dev Optional functions from the BEP20 standard.\n */\nabstract contract BEP20Detailed is IBEP20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IBEP20-balanceOf} and {IBEP20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n"
    },
    "/contracts/bsc/BEP20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.19;\n\nimport \"./IBEP20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IBEP20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {BEP20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of BEP20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IBEP20-approve}.\n */\n\n\ninterface IPankakeSwapExchange {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function sync() external;\n    function totalSupply() external view returns (uint256);\n}\n\ninterface IPankakeSwapRouter {\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function WETH() external pure returns (address);\n}\n\ninterface IReferralProgram {\n    function getSponsorOf(address referralAddress) external view returns (address);\n}\n\ncontract BEP20 is IBEP20 {\n    using SafeMath for uint256;\n\n    uint256 constant PRECISION = 10**18;\n\n    address internal _owner;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n\n    uint256 private _lastExchangeTotalSupply;\n\n\n    mapping (address => uint256) internal _totalIncomingTransfersAmounts;\n\n    mapping (address => uint256) internal _totalOutgoingTransfersAmounts;\n\n    mapping (address => uint256) internal _referralUnlocks;\n\n    mapping (address => bool) private _totallyUnlockedAddresses;\n\n    mapping (address => uint256) private _lastBuyTimestamps;\n\n    mapping (address => uint256) internal _firstBuyRates;\n\n    mapping (address => bool) private _exchangesAddresses;\n\n    mapping (address => bool) public autoSaleMode;\n\n    mapping (address => bool) public isActivated;\n\n    mapping (address => bool) public allowedContracts;\n\n    uint256 public autoSaleModeSoldTokenBalance;\n    uint256 public autoSaleModeBoughtBnbBalance;\n\n\n\n    uint256 public startRate = 10**16;\n    uint256 public rateThresholdCoef = 10**16;\n    uint256 public unlockPerStep = 10**13;\n\n    uint256 public currMaxUsdtRate = 0;\n\n    uint256 public inactiveInflationCoef = 8 * 10**17;\n    uint256 public inactivityPeriod = 1 weeks;\n    // uint256 public inactivityPeriod = 20 seconds;\n\n    uint256 public minUsdtBuyAmountToStayActive = 10 * 10**18;\n\n\n\n    address public _triggerWalletAddress;\n\n\n\n    IPankakeSwapExchange public exchange;\n    IReferralProgram public referralProgram;\n    IPankakeSwapRouter public router;\n    IBEP20 usdtToken;\n\n    address public factoryAddress;\n\n\n\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"You are not the owner\");\n        _;\n    }\n\n    function max(uint256 a, uint256 b) external pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n    \n    function min(uint256 a, uint256 b) external pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n\n    function pow(uint256 base, uint256 exp) public pure returns (uint256) {\n        if (exp == 0) {\n            return PRECISION; // Любое число в степени 0 равно 1\n        }\n\n        uint256 result = PRECISION;\n        uint256 k = base;\n\n        while (exp != 0) {\n            if (exp % 2 == 1) {\n                result = (result * k) / PRECISION;\n            }\n            exp /= 2;\n            k = (k * k) / PRECISION;\n        }\n\n        return result;\n    }\n\n    function isContract(address addr) public view returns (bool) {\n        return addr.code.length > 0;\n    }\n\n    function addContractToAllowed(address addr) public onlyOwner {\n        allowedContracts[addr] = true;\n    }\n\n    function removeContractFromAllowed(address addr) public onlyOwner {\n        allowedContracts[addr] = false;\n    }\n\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        hex\"a5934690703a592a07e841ca29d5e5c79b5e22ed4749057bb216dc31100be1c0\" // init code hash\n                    )\n                )\n            ))\n        );\n    }\n\n    function isPancakeSwapPool(address potentialPoolAddress) internal returns (bool) {\n        if(!isContract(potentialPoolAddress)){\n            return false;\n        }\n        bytes4 SELECTOR0 = bytes4(keccak256(bytes(\"token0()\")));\n        bytes4 SELECTOR1 = bytes4(keccak256(bytes(\"token1()\")));\n        (bool success0, bytes memory data0) = potentialPoolAddress.call(abi.encodeWithSelector(SELECTOR0));\n        (bool success1, bytes memory data1) = potentialPoolAddress.call(abi.encodeWithSelector(SELECTOR1));\n        if(!success0 || !success1){\n            return false;\n        }\n        address token0 = abi.decode(data0, (address));\n        address token1 = abi.decode(data1, (address));\n        if(token0 == address(0) || token1 == address(0) || token0 == token1){\n            return false;\n        }\n        if(token0 == address(this) || token1 == address(this)){\n            address pairAddress = pairFor(factoryAddress, token0, token1);\n            return pairAddress == potentialPoolAddress;\n        }\n        return false;\n    }\n\n\n    function getCurrentUnlockCoef(address addr) public view returns (uint256) {\n        uint256 firstBuyRate = _firstBuyRates[addr];\n        if(firstBuyRate == 0){\n            return 0;\n        }\n        uint256 rateThreshold = firstBuyRate.mul(rateThresholdCoef).div(PRECISION);\n        return currMaxUsdtRate.sub(firstBuyRate).div(rateThreshold).mul(unlockPerStep);\n    }\n\n    function getUsdtRate() public view returns (uint256) {\n        if(address(exchange) == address(0)) {\n            return startRate;\n        }\n\n        uint256 tokenUsdtRate;\n        (uint112 reserve0, uint112 reserve1, ) = exchange.getReserves();\n        if(address(this) == exchange.token0()){\n            tokenUsdtRate = uint256(reserve1).mul(PRECISION).div(uint256(reserve0));\n        } else {\n            tokenUsdtRate = uint256(reserve0).mul(PRECISION).div(uint256(reserve1));\n        }\n        return tokenUsdtRate;\n    }\n\n\n    function getAutoSaleModeOn(address account) public view returns (bool) {\n        return !autoSaleMode[account];\n    }\n\n    function getIsActivated(address account) public view returns (bool) {\n        return isActivated[account];\n    }\n    \n\n    function addToTotallyUnlockedAddresses(address addr) public onlyOwner returns (bool) {\n        _totallyUnlockedAddresses[addr] = true;\n        isActivated[addr] = true;\n        return true;\n    }\n\n    function removeFromTotallyUnlockedAddresses(address addr) public onlyOwner returns (bool) {\n        _totallyUnlockedAddresses[addr] = false;\n        return true;\n    }\n\n    function addToExchangesAddresses(address addr) public onlyOwner returns (bool) {\n        _exchangesAddresses[addr] = true;\n        return true;\n    }\n\n    function removeFromExchangesAddresses(address addr) public onlyOwner returns (bool) {\n        _exchangesAddresses[addr] = false;\n        return true;\n    }\n\n    function getLastBuyTimestamp(address addr) public view returns (uint256) {\n        return _lastBuyTimestamps[addr];\n    }\n\n\n    /**\n     * @dev See {IBEP20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IBEP20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        // rule 6\n        if(address(exchange) != address(0) && isContract(account) && !allowedContracts[account]){\n            return 0;\n        }\n        return _balances[account].mul(this.getIncomingInflationCoefficient(account)).div(PRECISION);\n    }\n\n\n    function availableBalanceOf(address account) public view returns (uint256) {\n        // rule 6\n        if(address(exchange) != address(0) && isContract(account) && !allowedContracts[account]){\n            return 0;\n        }\n        uint256 unlockAmount = _totalIncomingTransfersAmounts[account].mul(getCurrentUnlockCoef(account)).div(PRECISION) + _referralUnlocks[account];\n        uint256 balance = (_totallyUnlockedAddresses[account] || unlockAmount >= _balances[account]) ? _balances[account] : (_totalOutgoingTransfersAmounts[account] > unlockAmount ? 0 : unlockAmount.sub(_totalOutgoingTransfersAmounts[account]));\n        return balance.mul(this.getIncomingInflationCoefficient(account)).div(PRECISION);\n    }\n\n\n    function _makeReferralUnlocksIfNeeded(address buyer, uint256 amount) internal {\n        address sponsor = referralProgram.getSponsorOf(buyer);\n        if(sponsor != address(0)) {\n            uint256 referralAmount = amount.mul(5).div(100);\n            _referralUnlocks[sponsor] = _referralUnlocks[sponsor].add(referralAmount.mul(this.getOutgoingInflationCoefficient(sponsor)).div(PRECISION));\n        }\n    }\n\n    function makeReferralUnlocksIfNeeded(address buyer, uint256 amount) public onlyOwner {\n        _makeReferralUnlocksIfNeeded(buyer, amount);\n    }\n    \n\n    function getCurrentUnlockAmount(address addr) public view returns (uint256) {\n        return _totalIncomingTransfersAmounts[addr].mul(getCurrentUnlockCoef(addr)).div(PRECISION) + _referralUnlocks[addr];\n    }\n\n    function getReferralUnlockAmount(address addr) public view returns (uint256) {\n        return _referralUnlocks[addr];\n    }\n\n    function updateCurrMaxUsdtRateIfNeeded() internal {\n        uint256 currRate = getUsdtRate();\n        if(currRate < startRate) {\n            return;\n        }\n        if(currRate > currMaxUsdtRate) {\n            currMaxUsdtRate = currRate;\n        }\n    }\n\n    function getIncomingInflationCoefficient(address addr) public view returns (uint256) {\n        uint256 lastBuyTimestamp = _lastBuyTimestamps[addr];\n        if(lastBuyTimestamp == 0 || _totallyUnlockedAddresses[addr]) {\n            return PRECISION;\n        }\n        uint256 timePassed = block.timestamp.sub(lastBuyTimestamp);\n        uint256 inactiveInflation = pow(inactiveInflationCoef, timePassed.div(inactivityPeriod));\n        return inactiveInflation;\n    }\n\n\n    function getOutgoingInflationCoefficient(address addr) public view returns (uint256) {\n        uint256 lastBuyTimestamp = _lastBuyTimestamps[addr];\n        if(lastBuyTimestamp == 0 || _totallyUnlockedAddresses[addr]) {\n            return PRECISION;\n        }\n        uint256 timePassed = block.timestamp.sub(lastBuyTimestamp);\n        uint256 inactiveInflation = pow(PRECISION.mul(PRECISION).div(inactiveInflationCoef), timePassed.div(inactivityPeriod));\n        return inactiveInflation;\n    }\n\n\n    function applyInflationToBuyIfNeeded (address sender, address recipient, uint256 amount) internal {\n        uint256 inflationCoefficient = getIncomingInflationCoefficient(recipient);\n        if (amount.mul(this.getUsdtRate()).div(PRECISION) >= minUsdtBuyAmountToStayActive && _exchangesAddresses[sender]) {\n            if(inflationCoefficient < PRECISION) {\n                uint256 balanceBeforeInflation = _balances[recipient];\n                _balances[recipient] = _balances[recipient].mul(inflationCoefficient).div(PRECISION);\n                _totalIncomingTransfersAmounts[recipient] = _totalIncomingTransfersAmounts[recipient].mul(inflationCoefficient).div(PRECISION);\n                _totalOutgoingTransfersAmounts[recipient] = _totalOutgoingTransfersAmounts[recipient].mul(inflationCoefficient).div(PRECISION);\n                _referralUnlocks[recipient] = _referralUnlocks[recipient].mul(inflationCoefficient).div(PRECISION);\n                _totalSupply = _totalSupply.sub(balanceBeforeInflation.sub(_balances[recipient]));\n            }\n            _lastBuyTimestamps[recipient] = block.timestamp;\n        } else {\n            if(_lastBuyTimestamps[recipient] == 0) {\n                _lastBuyTimestamps[recipient] = block.timestamp;\n            }\n        }\n    }\n\n\n    function mintToPoolIfNeeded (uint256 amount) internal {\n        if(address(exchange) == address(0)) {\n            return;\n        }\n\n        uint256 tokenUsdtRate;\n        (uint112 reserve0, uint112 reserve1, ) = exchange.getReserves();\n\n        uint256 tokenReserve;\n        uint256 usdtReserve;\n\n        if(address(this) == exchange.token0()){\n            tokenReserve = uint256(reserve0);\n            usdtReserve = uint256(reserve1);\n        } else {\n            tokenReserve = uint256(reserve1);\n            usdtReserve = uint256(reserve0);\n        }\n\n        tokenUsdtRate = uint256(usdtReserve).mul(PRECISION).div(uint256(tokenReserve));\n\n        // uint256 k = tokenReserve.mul(usdtReserve);\n\n        uint256 tokenReserveAfterBuy = tokenReserve - amount;\n        // uint256 usdtReserveAfterBuy = k.div(tokenReserveAfterBuy);\n        uint256 usdtReserveAfterBuy = this.min(tokenReserve.mul(usdtReserve).div(tokenReserveAfterBuy), usdtToken.balanceOf(address(exchange))); // min impltementing rule 3\n\n        uint256 maxTokenUsdtRateAfterBuy = tokenUsdtRate.add(tokenUsdtRate.div(100));\n\n        uint256 tokenMinReserveAfterBuy = usdtReserveAfterBuy.mul(PRECISION).div(maxTokenUsdtRateAfterBuy);\n\n        uint256 mintAmount;\n        if(tokenReserveAfterBuy >= tokenMinReserveAfterBuy){\n            mintAmount = amount.div(2);\n        } else {\n            mintAmount = this.max(tokenMinReserveAfterBuy.sub(tokenReserveAfterBuy), amount.div(2));\n        }\n        \n        _mint(address(exchange), mintAmount);\n    }\n\n\n    receive() external payable {}\n\n    function autoSaleSellCoin (uint256 amount) public onlyOwner returns (bool) {\n        _mint(address(this), amount);\n        _approve(address(this), address(router), _allowances[address(this)][address(router)].add(amount));\n\n        address[] memory path = new address[](3);\n        path[0] = address(this);\n        if(address(this) == exchange.token0()){\n            path[1] = exchange.token1();\n        } else {\n            path[1] = exchange.token0();\n        }\n        path[2] = router.WETH();\n        uint[] memory amounts = router.swapExactTokensForETH(amount, 1, path, address(this), block.timestamp + 600 seconds);\n        autoSaleModeSoldTokenBalance += amount;\n        autoSaleModeBoughtBnbBalance += amounts[2];\n        return true;\n    }\n\n    function getAutoSaleRate() public view returns (uint256) {\n        return autoSaleModeBoughtBnbBalance.mul(PRECISION).div(autoSaleModeSoldTokenBalance);\n    }\n\n    function autoSaleGetProfit(address account, uint256 comissionFee) public onlyOwner returns (bool) {\n        require(!autoSaleMode[account], \"Auto sale mode for this account is turned off\");\n        uint256 availableAmount = availableBalanceOf(account);\n        uint256 tokenBnbRate = getAutoSaleRate();\n        uint256 availableBnbAmount;\n        if(availableAmount > autoSaleModeSoldTokenBalance){\n            availableAmount = autoSaleModeSoldTokenBalance;\n            availableBnbAmount = autoSaleModeBoughtBnbBalance;\n        } else {\n            availableBnbAmount = availableAmount.mul(tokenBnbRate).div(PRECISION);\n        }\n        require(comissionFee.mul(20) <= availableBnbAmount, \"Too big fee\");\n        uint256 bnbAmountToSend = availableBnbAmount - comissionFee;\n        autoSaleModeSoldTokenBalance = autoSaleModeSoldTokenBalance.sub(availableAmount);\n        autoSaleModeBoughtBnbBalance = autoSaleModeBoughtBnbBalance.sub(availableBnbAmount);\n\n        _burn(account, availableAmount);\n        \n        // payable(account).transfer(bnbAmountToSend);\n\n        (bool success, ) = payable(account).call{value: bnbAmountToSend}(\"\");\n        require(success, \"Not enough BNB\");\n\n        return true;\n    }\n\n    function retrieveBnbFees() public onlyOwner returns (bool) {\n        // payable(msg.sender).transfer(address(this).balance);\n\n        uint256 amount = address(this).balance.sub(autoSaleModeBoughtBnbBalance);\n\n        require(amount > 0, \"Nothing to retrieve\");\n\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Not enough BNB\");\n\n        return true;\n    }\n\n\n    /**\n     * @dev See {IBEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IBEP20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IBEP20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IBEP20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {BEP20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IBEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IBEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n        require(isActivated[sender], \"Sender is not activated\");\n\n        // rule 1-2\n        require(address(exchange) == address(0) || recipient == address(exchange) || !isPancakeSwapPool(recipient), \"Rejected transfer to different Pancake pool\");\n        // rule 5\n        require(address(exchange) == address(0) || ((!isContract(sender) || allowedContracts[sender]) && (!isContract(recipient) || allowedContracts[recipient])), \"Rejected transfer from/to contract\");\n        // rule 4\n        require(address(exchange) == address(0) || _totallyUnlockedAddresses[sender] || _totallyUnlockedAddresses[recipient] || balanceOf(recipient) > 0, \"Rejected transfer to account with zero balance\");\n\n        if(!isActivated[recipient]){\n            isActivated[recipient] = true;\n        }\n\n        if(_firstBuyRates[recipient] == 0){\n            _firstBuyRates[recipient] = getUsdtRate();\n        }\n\n        if(address(exchange) == sender) {\n            if(exchange.totalSupply() >= _lastExchangeTotalSupply) {\n                updateCurrMaxUsdtRateIfNeeded();\n                _makeReferralUnlocksIfNeeded(recipient, amount);\n                mintToPoolIfNeeded(amount);\n                _mint(_owner, amount.div(20));\n            }\n        }\n\n        if(address(exchange) != address(0)) {\n            _lastExchangeTotalSupply = exchange.totalSupply();\n        }\n\n        require(amount <= availableBalanceOf(sender), \"BEP20: transfer amount exceeds available balance\");\n\n        applyInflationToBuyIfNeeded(sender, recipient, amount);\n\n        uint256 sendAmount = amount.mul(this.getOutgoingInflationCoefficient(sender)).div(PRECISION);\n        uint256 receiveAmount = amount.mul(this.getOutgoingInflationCoefficient(recipient)).div(PRECISION);\n\n        _balances[sender] = _balances[sender].sub(sendAmount);\n        _balances[recipient] = _balances[recipient].add(receiveAmount);\n\n        _totalOutgoingTransfersAmounts[sender] = _totalOutgoingTransfersAmounts[sender].add(sendAmount);\n        _totalIncomingTransfersAmounts[recipient] = _totalIncomingTransfersAmounts[recipient].add(receiveAmount);\n\n        if(recipient == _triggerWalletAddress){\n            autoSaleMode[sender] = !autoSaleMode[sender];\n        }\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n\n        uint256 inflatedAmount = amount.mul(this.getOutgoingInflationCoefficient(account)).div(PRECISION);\n\n        _balances[account] = _balances[account].add(inflatedAmount);\n        _totalIncomingTransfersAmounts[account] = _totalIncomingTransfersAmounts[account].add(inflatedAmount);\n        _lastBuyTimestamps[account] = block.timestamp;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        uint256 inflatedAmount = value.mul(this.getOutgoingInflationCoefficient(account)).div(PRECISION);\n\n        _totalSupply = _totalSupply.sub(value);\n\n        _balances[account] = _balances[account].sub(inflatedAmount);\n        _totalOutgoingTransfersAmounts[account] = _totalOutgoingTransfersAmounts[account].add(inflatedAmount);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}