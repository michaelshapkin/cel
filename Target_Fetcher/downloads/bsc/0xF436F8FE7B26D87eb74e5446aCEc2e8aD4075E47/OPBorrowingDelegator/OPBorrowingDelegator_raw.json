{{
  "language": "Solidity",
  "sources": {
    "/contracts/OPBorrowingDelegator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nimport \"./common/DelegatorInterface.sol\";\nimport \"./common/Adminable.sol\";\nimport \"./IOPBorrowing.sol\";\n\ncontract OPBorrowingDelegator is DelegatorInterface, Adminable {\n    constructor(\n        OPBorrowingStorage.MarketConf memory _marketDefConf,\n        OPBorrowingStorage.LiquidationConf memory _liquidationConf,\n        address payable _admin,\n        address implementation_\n    ) {\n        admin = payable(msg.sender);\n        // Creator of the contract is admin during initialization\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(implementation_, abi.encodeWithSelector(IOPBorrowing(implementation_).initialize.selector, _marketDefConf, _liquidationConf));\n        implementation = implementation_;\n        // Set the proper admin now that initialization is done\n        admin = _admin;\n    }\n\n    /**\n     * Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function setImplementation(address implementation_) public override onlyAdmin {\n        address oldImplementation = implementation;\n        implementation = implementation_;\n        emit NewImplementation(oldImplementation, implementation);\n    }\n}\n"
    },
    "/contracts/interfaces/XOLEInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\ninterface XOLEInterface {\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "/contracts/interfaces/OpenLevInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\ninterface OpenLevInterface {\n    struct Market {\n        // Market info\n        address pool0; // Lending Pool 0\n        address pool1; // Lending Pool 1\n        address token0; // Lending Token 0\n        address token1; // Lending Token 1\n        uint16 marginLimit; // Margin ratio limit for specific trading pair. Two decimal in percentage, ex. 15.32% => 1532\n        uint16 feesRate; // feesRate 30=>0.3%\n        uint16 priceDiffientRatio;\n        address priceUpdater;\n        uint256 pool0Insurance; // Insurance balance for token 0\n        uint256 pool1Insurance; // Insurance balance for token 1\n    }\n\n    function markets(uint16 marketId) external view returns (Market memory market);\n\n    function taxes(uint16 marketId, address token, uint index) external view returns (uint24);\n\n    function getMarketSupportDexs(uint16 marketId) external view returns (uint32[] memory);\n\n    function updatePrice(uint16 marketId, bytes memory dexData) external;\n}\n"
    },
    "/contracts/interfaces/OPBuyBackInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\ninterface OPBuyBackInterface {\n    function transferIn(address token, uint amount) external;\n}\n"
    },
    "/contracts/interfaces/LPoolInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\ninterface LPoolInterface {\n    function underlying() external view returns (address);\n\n    function totalBorrows() external view returns (uint);\n\n    function borrowBalanceCurrent(address account) external view returns (uint);\n\n    function borrowBalanceStored(address account) external view returns (uint);\n\n    function borrowBehalf(address borrower, uint borrowAmount) external;\n\n    function repayBorrowBehalf(address borrower, uint repayAmount) external;\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external;\n}\n"
    },
    "/contracts/interfaces/DexAggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\ninterface DexAggregatorInterface {\n    function getPrice(address desToken, address quoteToken, bytes memory data) external view returns (uint256 price, uint8 decimals);\n\n    function getPriceCAvgPriceHAvgPrice(\n        address desToken,\n        address quoteToken,\n        uint32 secondsAgo,\n        bytes memory dexData\n    ) external view returns (uint256 price, uint256 cAvgPrice, uint256 hAvgPrice, uint8 decimals, uint256 timestamp);\n\n    function updatePriceOracle(address desToken, address quoteToken, uint32 timeWindow, bytes memory data) external returns (bool);\n\n    function getToken0Liquidity(address token0, address token1, bytes memory dexData) external view returns (uint);\n\n    function getPairLiquidity(address token0, address token1, bytes memory dexData) external view returns (uint token0Liq, uint token1Liq);\n\n    function buy(\n        address buyToken,\n        address sellToken,\n        uint24 buyTax,\n        uint24 sellTax,\n        uint buyAmount,\n        uint maxSellAmount,\n        bytes memory data\n    ) external returns (uint sellAmount);\n\n    function sell(address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) external returns (uint buyAmount);\n}\n"
    },
    "/contracts/interfaces/ControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\ninterface ControllerInterface {\n    function collBorrowAllowed(uint marketId, address borrower, bool collateralIndex) external view returns (bool);\n\n    function collRepayAllowed(uint marketId) external view returns (bool);\n\n    function collRedeemAllowed(uint marketId) external view returns (bool);\n\n    function collLiquidateAllowed(uint marketId) external view returns (bool);\n}\n"
    },
    "/contracts/common/DelegatorInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nabstract contract DelegatorInterface {\n    /**\n     * Implementation address for this contract\n     */\n    address public implementation;\n\n    /**\n     * Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function setImplementation(address implementation_) public virtual;\n\n    /**\n     * Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n\n    /**\n     * Delegates execution to the implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n        return delegateTo(implementation, data);\n    }\n\n    /**\n     * Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    }\n\n    /**\n     * Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    receive() external payable {\n        _fallback();\n    }\n\n    function _fallback() internal {\n        // delegate all other functions to current implementation\n        if (msg.data.length > 0) {\n            (bool success, ) = implementation.delegatecall(msg.data);\n            assembly {\n                let free_mem_ptr := mload(0x40)\n                returndatacopy(free_mem_ptr, 0, returndatasize())\n                switch success\n                case 0 {\n                    revert(free_mem_ptr, returndatasize())\n                }\n                default {\n                    return(free_mem_ptr, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "/contracts/common/Adminable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nabstract contract Adminable {\n    address payable public admin;\n    address payable public pendingAdmin;\n    address payable public developer;\n\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() {\n        developer = payable(msg.sender);\n    }\n\n    modifier onlyAdmin() {\n        checkAdmin();\n        _;\n    }\n    modifier onlyAdminOrDeveloper() {\n        require(msg.sender == admin || msg.sender == developer, \"Only admin or dev\");\n        _;\n    }\n\n    function setPendingAdmin(address payable newPendingAdmin) external virtual onlyAdmin {\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    function acceptAdmin() external virtual {\n        require(msg.sender == pendingAdmin, \"Only pendingAdmin\");\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = payable(0);\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    function checkAdmin() private view {\n        require(msg.sender == admin, \"caller must be admin\");\n    }\n}\n"
    },
    "/contracts/IOPBorrowing.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nimport \"./interfaces/LPoolInterface.sol\";\nimport \"./interfaces/OpenLevInterface.sol\";\nimport \"./interfaces/ControllerInterface.sol\";\nimport \"./interfaces/DexAggregatorInterface.sol\";\nimport \"./interfaces/XOLEInterface.sol\";\nimport \"./interfaces/OPBuyBackInterface.sol\";\n\ncontract OPBorrowingStorage {\n    event NewMarket(uint16 marketId, LPoolInterface pool0, LPoolInterface pool1, address token0, address token1, uint32 dex, uint token0Liq, uint token1Liq);\n\n    event Borrow(address indexed borrower, uint16 marketId, bool collateralIndex, uint collateral, uint borrow, uint borrowFees);\n\n    event Repay(address indexed borrower, uint16 marketId, bool collateralIndex, uint repayAmount, uint collateral);\n\n    event Redeem(address indexed borrower, uint16 marketId, bool collateralIndex, uint collateral);\n\n    event Liquidate(\n        address indexed borrower,\n        uint16 marketId,\n        bool collateralIndex,\n        address liquidator,\n        uint collateralDecrease,\n        uint repayAmount,\n        uint outstandingAmount,\n        uint liquidateFees,\n        uint token0Price\n    );\n\n    event NewLiquidity(uint16 marketId, uint oldToken0Liq, uint oldToken1Liq, uint newToken0Liq, uint newToken1Liq);\n\n    event NewMarketConf(\n        uint16 marketId,\n        uint16 collateralRatio,\n        uint16 maxLiquidityRatio,\n        uint16 borrowFeesRatio,\n        uint16 insuranceRatio,\n        uint16 poolReturnsRatio,\n        uint16 liquidateFeesRatio,\n        uint16 liquidatorReturnsRatio,\n        uint16 liquidateInsuranceRatio,\n        uint16 liquidatePoolReturnsRatio,\n        uint16 liquidateMaxLiquidityRatio,\n        uint16 twapDuration\n    );\n\n    struct Market {\n        LPoolInterface pool0; // pool0 address\n        LPoolInterface pool1; // pool1 address\n        address token0; // token0 address\n        address token1; // token1 address\n        uint32 dex; // decentralized exchange\n    }\n\n    struct MarketConf {\n        uint16 collateralRatio; //  the collateral ratio, 6000 => 60%\n        uint16 maxLiquidityRatio; // the maximum pool's total borrowed cannot be exceeded dex liquidity*ratio, 1000 => 10%\n        uint16 borrowFeesRatio; // the borrowing fees ratio, 30 => 0.3%\n        uint16 insuranceRatio; // the insurance percentage of the borrowing fees, 3000 => 30%\n        uint16 poolReturnsRatio; // the pool's returns percentage of the borrowing fees, 3000 => 30%\n        uint16 liquidateFeesRatio; // the liquidation fees ratio, 100 => 1%\n        uint16 liquidatorReturnsRatio; // the liquidator returns percentage of the liquidation fees, 3000 => 30%\n        uint16 liquidateInsuranceRatio; // the insurance percentage of the liquidation fees, 3000 => 30%\n        uint16 liquidatePoolReturnsRatio; // the pool's returns percentage of the liquidation fees, 3000 => 30%\n        uint16 liquidateMaxLiquidityRatio; // the maximum liquidation amount cannot be exceeded dex liquidity*ratio, 1000=> 10%\n        uint16 twapDuration; // the TWAP duration, 60 => 60s\n    }\n\n    struct Liquidity {\n        uint token0Liq; // the token0 liquidity\n        uint token1Liq; // the token1 liquidity\n    }\n\n    struct Insurance {\n        uint insurance0; // the token0 insurance\n        uint insurance1; // the token1 insurance\n    }\n\n    struct LiquidationConf {\n        uint128 liquidatorXOLEHeld; //  the minimum amount of xole held by liquidator\n        uint8 priceDiffRatio; // the maximum ratio of real price diff TWAP, 10 => 10%\n        OPBuyBackInterface buyBack; // the ole buyback contract address\n    }\n\n    uint internal constant RATIO_DENOMINATOR = 10000;\n\n    address public immutable wETH;\n\n    OpenLevInterface public immutable openLev;\n\n    ControllerInterface public immutable controller;\n\n    DexAggregatorInterface public immutable dexAgg;\n\n    XOLEInterface public immutable xOLE;\n\n    // mapping of marketId to market info\n    mapping(uint16 => Market) public markets;\n\n    // mapping of marketId to market config\n    mapping(uint16 => MarketConf) public marketsConf;\n\n    // mapping of borrower, marketId, collateralIndex to collateral shares\n    mapping(address => mapping(uint16 => mapping(bool => uint))) public activeCollaterals;\n\n    // mapping of marketId to insurances\n    mapping(uint16 => Insurance) public insurances;\n\n    // mapping of marketId to time weighted average liquidity\n    mapping(uint16 => Liquidity) public twaLiquidity;\n\n    // mapping of token address to total shares\n    mapping(address => uint) public totalShares;\n\n    MarketConf public marketDefConf;\n\n    LiquidationConf public liquidationConf;\n\n    constructor(OpenLevInterface _openLev, ControllerInterface _controller, DexAggregatorInterface _dexAgg, XOLEInterface _xOLE, address _wETH) {\n        openLev = _openLev;\n        controller = _controller;\n        dexAgg = _dexAgg;\n        xOLE = _xOLE;\n        wETH = _wETH;\n    }\n}\n\ninterface IOPBorrowing {\n    function initialize(OPBorrowingStorage.MarketConf memory _marketDefConf, OPBorrowingStorage.LiquidationConf memory _liquidationConf) external;\n\n    // only controller\n    function addMarket(uint16 marketId, LPoolInterface pool0, LPoolInterface pool1, bytes memory dexData) external;\n\n    /*** Borrower Functions ***/\n    function borrow(uint16 marketId, bool collateralIndex, uint collateral, uint borrowing) external payable;\n\n    function repay(uint16 marketId, bool collateralIndex, uint repayAmount, bool isRedeem) external payable returns (uint redeemShare);\n\n    function redeem(uint16 marketId, bool collateralIndex, uint collateral) external;\n\n    function liquidate(uint16 marketId, bool collateralIndex, address borrower) external;\n\n    function collateralRatio(uint16 marketId, bool collateralIndex, address borrower) external view returns (uint current);\n\n    /*** Admin Functions ***/\n    function migrateOpenLevMarkets(uint16 from, uint16 to) external;\n\n    function setTwaLiquidity(uint16[] calldata marketIds, OPBorrowingStorage.Liquidity[] calldata liquidity) external;\n\n    function setMarketConf(uint16 marketId, OPBorrowingStorage.MarketConf calldata _marketConf) external;\n\n    function setMarketDex(uint16 marketId, uint32 dex) external;\n\n    function moveInsurance(uint16 marketId, bool tokenIndex, address to, uint moveShare) external;\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}