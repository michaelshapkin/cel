{{
  "language": "Solidity",
  "sources": {
    "/contracts/RewardVaultDelegator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nimport \"./Adminable.sol\";\nimport \"./DelegatorInterface.sol\";\n\ncontract RewardVaultDelegator is DelegatorInterface, Adminable {\n\n    constructor(\n        address payable _admin,\n        address _distributor,\n        uint64 _defaultExpireDuration,\n        address implementation_){\n        admin = payable(msg.sender);\n        // Creator of the contract is admin during initialization\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,uint64)\",\n            _admin,\n            _distributor,\n            _defaultExpireDuration\n            ));\n        implementation = implementation_;\n        // Set the proper admin now that initialization is done\n        admin = _admin;\n    }\n\n    /**\n     * Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function setImplementation(address implementation_) public override onlyAdmin {\n        address oldImplementation = implementation;\n        implementation = implementation_;\n        emit NewImplementation(oldImplementation, implementation);\n    }\n}\n"
    },
    "/contracts/DelegatorInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nabstract contract DelegatorInterface {\n    /**\n     * Implementation address for this contract\n     */\n    address public implementation;\n\n    /**\n     * Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function setImplementation(address implementation_) public virtual;\n\n    /**\n     * Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n\n    /**\n     * Delegates execution to the implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n        return delegateTo(implementation, data);\n    }\n\n    /**\n     * Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    }\n\n    /**\n     * Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    receive() external payable {\n        _fallback();\n    }\n\n    function _fallback() internal {\n        // delegate all other functions to current implementation\n        if (msg.data.length > 0) {\n            (bool success, ) = implementation.delegatecall(msg.data);\n            assembly {\n                let free_mem_ptr := mload(0x40)\n                returndatacopy(free_mem_ptr, 0, returndatasize())\n                switch success\n                case 0 {\n                    revert(free_mem_ptr, returndatasize())\n                }\n                default {\n                    return(free_mem_ptr, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "/contracts/Adminable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.15;\n\nabstract contract Adminable {\n    address payable public admin;\n    address payable public pendingAdmin;\n    address payable public developer;\n\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() {\n        developer = payable(msg.sender);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"caller must be admin\");\n        _;\n    }\n    modifier onlyAdminOrDeveloper() {\n        require(msg.sender == admin || msg.sender == developer, \"caller must be admin or developer\");\n        _;\n    }\n\n    function setPendingAdmin(address payable newPendingAdmin) external virtual onlyAdmin {\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    function acceptAdmin() external virtual {\n        require(msg.sender == pendingAdmin, \"only pendingAdmin can accept admin\");\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n        // Store admin with value pendingAdmin\n        admin = payable(oldPendingAdmin);\n        // Clear the pending value\n        pendingAdmin = payable(0);\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}